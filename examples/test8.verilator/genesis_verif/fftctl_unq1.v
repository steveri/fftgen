//
//--------------------------------------------------------------------------------
//          THIS FILE WAS AUTOMATICALLY GENERATED BY THE GENESIS2 ENGINE        
//  FOR MORE INFORMATION: OFER SHACHAM (CHIP GENESIS INC / STANFORD VLSI GROUP)
//    !! THIS VERSION OF GENESIS2 IS NOT FOR ANY COMMERCIAL USE !!
//     FOR COMMERCIAL LICENSE CONTACT SHACHAM@ALUMNI.STANFORD.EDU
//--------------------------------------------------------------------------------
//
//  
//	-----------------------------------------------
//	|            Genesis Release Info             |
//	|  $Change: 11904 $ --- $Date: 2013/08/03 $   |
//	-----------------------------------------------
//	
//
//  Source file: /nobackup/steveri/github/fftgen/rtl/fftctl.vp
//  Source template: fftctl
//
// --------------- Begin Pre-Generation Parameters Status Report ---------------
//
//	From 'generate' statement (priority=5):
// Parameter units_per_cycle 	= 1
// Parameter SRAM_TYPE 	= TRUE_1PORT
// Parameter swizzle_algorithm 	= round7
// Parameter n_fft_points 	= 8
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From Command Line input (priority=4):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From XML input (priority=3):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From Config File input (priority=2):
//
// ---------------- End Pre-Generation Pramameters Status Report ----------------

// Copyright 2013, all rights reserved.
// See below (end of file) for extended copyright information.
//
// Scheduling algorithm='round7'

// ---------------- Begin default Genesis2 parameter summary ----------------
//
// n_fft_points (_GENESIS2_INHERITANCE_PRIORITY_) = 8
//
// units_per_cycle (_GENESIS2_INHERITANCE_PRIORITY_) = 1
//
// SRAM_TYPE (_GENESIS2_INHERITANCE_PRIORITY_) = TRUE_1PORT
//
// swizzle_algorithm (_GENESIS2_INHERITANCE_PRIORITY_) = round7
//
// ---------------- End default Genesis2 parameter summary ----------------

////////////////////////////////////////////////////////////////////////
// module fftctl_unq1
//
// Usage: my $fftctl = generate('fftctl', 'fftctl'
//             , n_fft_points    => 1024
//             , units_per_cycle => 4
//             , SRAM_TYPE       => "1PORT_DBLPUMP"
//             );
//
// Where (default value is starred)
//   "n_fft_points"    can be any power of two greater than 8 (16*)
//   "units_per_cycle" can be 0.25, 0.5, 1.0*, 2.0 or 4.0
//   "SRAM_TYPE"       is either "1PORT_DBLPUMP" or "TRUE_1PORT"* (or "TRUE_2PORT")
//
// *default
//
// Example(s):  see above.

////////////////////////////////////////////////////////////////////////
// Parameter values used by this instantiation:
//     units_per_cycle (1)      Number active butterfly units per cycle (.25 means one unit at 1/4 speed)
//     SRAM_TYPE (TRUE_1PORT)   What kind of SRAM should the FFT use?
//     swizzle_algorithm (round7) round7 is the newest and best
//     n_fft_points (8)         Number of complex data values to process.
//
// Building ONE butterfly unit
// local_clock = global_clock/1
//
// Derived values:
//    $timestep (1) = time it takes (cycles) for butterfly unit to complete one operation
//    $nunits   (1)   = number of butterfly units we have to build (four maximum)
//


//    $nlevels  (3)  = levels (columns) in the (virtual) bfly network
//    $ncalcs_per_unit (12) = total ncalcs to be performed by each bfly unit

// swizzler algorithm 'round7'
//  0. Index ( 0, 1) => banks ( 0, 1),  twid(c,s) = ( 1.000,  0.000)
//  1. Index ( 2, 3) => banks ( 2, 3),  twid(c,s) = ( 1.000,  0.000)
//  2. Index ( 4, 5) => banks ( 0, 1),  twid(c,s) = ( 1.000,  0.000)
//  3. Index ( 6, 7) => banks ( 2, 3),  twid(c,s) = ( 1.000,  0.000)
//  4. Index ( 0, 2) => banks ( 0, 2),  twid(c,s) = ( 1.000,  0.000)
//  5. Index ( 4, 6) => banks ( 1, 3),  twid(c,s) = ( 1.000,  0.000)
//  6. Index ( 5, 7) => banks ( 0, 2),  twid(c,s) = ( 0.000, -1.000)
//  7. Index ( 1, 3) => banks ( 1, 3),  twid(c,s) = ( 0.000, -1.000)
//  8. Index ( 0, 4) => banks ( 0, 1),  twid(c,s) = ( 1.000,  0.000)
//  9. Index ( 2, 6) => banks ( 2, 3),  twid(c,s) = ( 0.000, -1.000)
// 10. Index ( 1, 5) => banks ( 0, 1),  twid(c,s) = ( 0.707, -0.707)
// 11. Index ( 3, 7) => banks ( 2, 3),  twid(c,s) = (-0.707, -0.707)
////////////////////////////////////////////////////////////////////////
// Will produce 3 levels (columns) in the (virtual) butterfly network.

module fftctl_unq1
  (
      //------------------------------------------------
      // begin fftctl->printwires('      ', 'io_list')

      input logic  clk_i,   // Clock
      input logic  rst_n_i, // Reset signal per power-up
      input logic  start_i, // Start signal per FFT

      // Butterfly unit operands
      output logic [2:0] BFLY0_op1_ix_o, 
      output logic [2:0] BFLY0_op2_ix_o, 

      // Per-butterfly access type
      output logic [2:0] BFLY0_access_type_o, 

      // Remaining output signals
      output logic [4:0] fftctl_cycle_num_o, // 0, 1, 2, ...
      output logic       busy_o,          // hi while busy computing fft
      output logic       fftclk_o,          // local_clk = global_clk/1
      
      // Bypass controls
      output logic [3:0] suppress_wz_o,  // one bit per bank, set 100 ps after posedge
      output logic [3:0] bypass_read_o,  // one bit per bank, set 100 ps after posedge
      output logic       bufnum_o[0:3]           // which buffer do we use for bypass (per bank)?

      // end fftctl->printwires()
      //------------------------------------------------
   );
   //////////////////////////////////////////////////////////////////////////////
   // DECLARATIONS

   // No lookup table because ($USE_LOOKUP_TABLE=0).

   // Will iterate on precomputed 'access_type' registers to control
   // bypassing.  *****Only used for 1port SRAM when nunits==1.*****
   // Three-bit registers hold one of five access types:
   // ("SRAM", "op1 from buf", "op2 from buf", "op1 to buf", "op2 to buf")

   logic [2:0] BFLY0_access_type [0:11];

   // For nunits>1, use precomputed bit vectors to control bypass buffers.
   // Each register has one bit per SRAM (i.e. four bits per butterfly unit),
   // to tell which (up to four) SRAM's are being bypassed in this cycle.
   // E.g. suppress_wz = "0000 0000 0000 0011" means that the writes destined
   // for SRAM001 and SRAM000 should go to bypass buffers instead.  "Bufnum"
   // tells which of up to four bypass buffers hold this data, thus "bufnum"
   // needs two bits per SRAM access.

   logic [0:3] precomputed_suppress_wz [0:11];      // {0,1}
   logic [0:3] precomputed_bypass_read [0:11];      // {0,1}
   logic       precomputed_bufnum[0:3][0:11];      // {0,1,2,3}

   // Need to count through array(s) from 0 to 11

   // FIXME FIXME FIXME same as fftram cycle_num but different than top_fft cycle_num :(
   // May need to count a cycle or two beyond minimum!  (Why?)
   logic [4:0] cycle_num;

   // Try it without, see what happens
   // logic [3:0] cycle_num;
   // NOPE 7 of 48 regression tests FAIL 
   // TR FAIL: 2 mismatched results --- 16 1 dpump
   // TR FAIL: 2 mismatched results --- 16 2 2port
   // TR FAIL: 2 mismatched results --- 16 4 2port
   // TR FAIL: 2 mismatched results --- 256 1 2port
   // TR FAIL: 2 mismatched results --- 256 2 dpump
   // TR FAIL: 2 mismatched results --- 256 4 2port


   // out2_offset is used to calculate op2 from op1.\n");
   logic [3:0] out2_offset;

   // Looks like we're (finally!) going to need a stage number.
   logic [2:0] stageno;

   // Control signals.
   logic       STARTED;
   logic       LAST;

   // [Optional code here iff $DEBUG_CRAZY_EYE==1]


   //////////////////////////////////////////////////////////////////////////////////////
   // FUNCTION: OP GENERATOR "GenOps" generates op1, op2
   // Given cynum, stageno, buttno, generate the appropriate ops for each butterfly
   //
   // deconstruct i = (cynum << log2(nbutts)) + butt_num
   // e.g. if cynum = 7 and nbutts=4 then i is one of {28,29,30,31}
   //
   // op1,op2 = f(i,stageno,npoints)
   //

   //////////////////////////////////////////////////////////////////////////////////////
   // FUNCTION: CRAZY-EYE
   //
   // CrazyEye turns old normal i into a crazy resequenced i (CrazyEye)

   //////////////////////////////////////////////////////////////////////////////////////
   // FUNCTION: OP GENERATOR "GenOps2" generates op1, op2 using round2/formal-proof alg.
   // Given cynum, stageno, buttno, generate the appropriate ops for each butterfly
   // deconstruct i = (cynum << log2(nbutts)) + butt_num
   // e.g. if cynum = 7 and nbutts=4 then i is one of {28,29,30,31}
   //
   // op1,op2 = f(i,stageno,npoints)
   //
   function [5:0] GenOps2;


      input [4:0] CyNum;   // Yes there's an extra bit DON'T CHANGE IT mos def
      input [0:0] ButtNum; // Yes there's an extra bit DON'T CHANGE IT i guess
      input [2:0] StageNo; // Yes there's an extra bit DON'T CHANGE IT i guess
       
      logic [2:0] ii, i, P, i_reordered;
      logic [2:0] op1;
      logic [2:0] op2;

      integer shift_amt;

      begin

         //////////////////////////////////////////////////////////////////////////////////////
         // Step 0, convert cynum/buttnum into an index.  RIGHT!??
         ii  = (((CyNum << 0) + ButtNum) & 3) << 1;
         //$display("GENOPS2 (t=%06d)           ii= %d", $time, ii);

         //////////////////////////////////////////////////////////////////////////////////////
         // Step 1, the rotate
         i = (StageNo <= 1) ?
             RotateLeft(ii, StageNo) :             // Rotate i left by StageNo bits
             RotateSubword(ii, StageNo);           // Rotate bottom t bits of i and move them to top
            
         $display("GENOPS2 (t=%06d) ii,i: (%1d,%1d) => (%1d,%1d)", $time, ii, ii+1, i, i+2**StageNo);
         $display("GENOPS2");

         // If there's no reordering, we're done.  Can use i and i+1 as op1 and op2,
         // yields a valid schedule although with multiple conflicts.  For conflict-
         // free schedule, must do reordering.

         //////////////////////////////////////////////////////////////////////////////////////
         // Step 2, the reorder
         // Replace appropriate bits in i w/ P(i) a.k.a. swizzle(i)

         P[0] = i[0] ^ i[2];
         P[1] = i[1];
         P[2] = i[0] ^ i[2];
         $display("GENOPS2 (t=%06d) > P = %08b", $time, P);

         case (StageNo) // Uh, use StageNo why not (used to be StageVec(?))
            0: i_reordered = {i[2],P[1],P[0]}; // NORMAL
            1: i_reordered = {P[2],P[1],i[0]}; // NORMAL
            2: i_reordered = {P[2],P[1],i[0]}; // OVERLAP
            // default: assert (0) $fatal("ERROR fftctl could not generate the craaaaaazy eye\n\n");
            // default: no_crazy: assert (0) $fatal("ERROR fftctl could not generate the craaaaaazy eye\n\n");
            // default: $fatal("ERROR fftctl could not generate the craaaaaazy eye\n\n");
         endcase
         $display("GENOPS2 (t=%06d) > ir= %08b", $time, i_reordered);

         op1 = i_reordered & ~(1'b1 << StageNo);  // To guarantee that op1 < op2.
         op2 = i_reordered |  (1'b1 << StageNo);

         $display("GENOPS2");
         $display("GENOPS2 (t=%06d) > op1= %08b", $time, {8'h0,op1});
         $display("GENOPS2 (t=%06d) > op2= %08b", $time, {8'h0,op2});
         $display("GENOPS2");
         $display("GENOPS2 (t=%06d) ops=(%d,%d)", $time, op1, op2);
         $display("GENOPS2 -----------------------------------------------------");

         GenOps2 = {op1,op2};
      end
   endfunction

   //////////////////////////////////////////////////////////////////////////////////////
   // FUNCTION: ROTATELEFT
   //
   // RotateLeft(i, StageNo):  Rotate reg i left by StageNo bits
   // i is known to have $iwidth bits, where $iwidth is log2($npoints) and $npoints
   // is a Genesis2 parameter of the fftctl module, which contains this function.

   // Perl setup and containing scope.

   function [2:0] RotateLeft;
      input [2:0] i;        // i counts 0..(npoints-1) per stage
      input [1:0] StageNo;  // StageNo is one of {0..(nstages-1)}

      logic [5:0] shifted_double_i;

      begin
         shifted_double_i = {i,i} << StageNo;
         RotateLeft = shifted_double_i[5:3];
      end
   endfunction


   //////////////////////////////////////////////////////////////////////////////////////
   // FUNCTION: ROTATESUBWORD
   //
   // RotateSubword(i, StageNo):  Rotate bottom T bits of reg i left by s bits, then move them to top.
   // s is (StageNo - (nstages-ntoggles))
   // i is known to have $iwidth bits, where $iwidth is log2($npoints) and $npoints
   // T is the number of toggle bits, which is log2(groupsize)
   // is a Genesis2 parameter of the fftctl module, which contains this function.

   // Perl setup and containing scope.

   function [2:0] RotateSubword;
      input [2:0] ii;        // i counts 0..(npoints-1) per stage
      input [1:0] StageNo;  // StageNo is one of {0..(nstages-1)}
      
      logic [1:0] low_T;
      logic [3:0] shifted_double_t;
      
      begin

         // Bottom T bits get rotated left s bits, e.g. if iwidth is 8 and ntoggles is 2,
         // low_T bits are [1:0] and new i is (rotated ii[1:0]) concat with ii[2:2]
         low_T = ii[1:0];
         shifted_double_t = {low_T,low_T} << (StageNo - 1);

         // Assemble the return value.
         // E.g. if ntoggles = 30 and iwidth=100, would have rs={sdt[59:30],i[69:0]}
         RotateSubword = {shifted_double_t[3:2], ii[2:2]};
      end
   endfunction




   //////////////////////////////////////////////////////////////////////////////////////
   // INIT BLOCKS

   initial begin
      cycle_num   <= 5'b0;
      STARTED     <= 1'b0;
      LAST        <= 1'b1;
      stageno     <= 3'b0;
      out2_offset <= 4'b1;
      $display("GENOPS2 -----------------------------------------------------");
      $display("GENOPS2 (t=%06d) STAGE 0", $time);
   end

   initial begin
      // No lookup table because ($USE_LOOKUP_TABLE=0).

      /////////////////////////////////////////////////////////////////////////////
      // Note: for nunits==1 suppress_wz and bypass_read are one-hot

       /***************** Stage 0: ******************/

       precomputed_suppress_wz[ 0] = 4'h0;
       precomputed_bypass_read[ 0] = 4'h0;
       precomputed_suppress_wz[ 1] = 4'h0;
       precomputed_bypass_read[ 1] = 4'h0;
       precomputed_suppress_wz[ 2] = 4'h0;
       precomputed_bypass_read[ 2] = 4'h0;
       precomputed_suppress_wz[ 3] = 4'h4;
       precomputed_bypass_read[ 3] = 4'h0;
       /***************** Stage 1: ******************/

       precomputed_suppress_wz[ 4] = 4'h0;
       precomputed_bypass_read[ 4] = 4'h0;
       precomputed_suppress_wz[ 5] = 4'h0;
       precomputed_bypass_read[ 5] = 4'h8;
       precomputed_suppress_wz[ 6] = 4'h0;
       precomputed_bypass_read[ 6] = 4'h0;
       precomputed_suppress_wz[ 7] = 4'h2;
       precomputed_bypass_read[ 7] = 4'h0;
       /***************** Stage 2: ******************/

       precomputed_suppress_wz[ 8] = 4'h0;
       precomputed_bypass_read[ 8] = 4'h0;
       precomputed_suppress_wz[ 9] = 4'h0;
       precomputed_bypass_read[ 9] = 4'h0;
       precomputed_suppress_wz[10] = 4'h0;
       precomputed_bypass_read[10] = 4'h1;
       precomputed_suppress_wz[11] = 4'h0;
       precomputed_bypass_read[11] = 4'h0;
   end

   //////////////////////////////////////////////////////////////////////////////////////
   // Initialize loop variables.

   always @(posedge start_i) if (~rst_n_i) begin
      cycle_num   <= 5'b0;
      STARTED     <= 1'b1;
      LAST        <= 1'b0;
      out2_offset <= 4'b1;
      suppress_wz_o <= 4'b0;
   end

   assign busy_o = ~LAST;

   //////////////////////////////////////////////////////////////////////////////////////
   // Generate local clock fftclk_o from global clock gclk
   // TODO: would feel better if divisor was passed in as a parameter rather than generated cross-module...?
   // TODO: if $upc==1 could maybe replace this with an ASSIGN
   fftclock_unq1  LCLK(.clock_in(clk_i), .clock_out(fftclk_o));

   //////////////////////////////////////////////////////////////////////////////////////
   // Fetch and deliver precomputed ops and bypass info on a per-cycle basis.


   always @(posedge fftclk_o) begin
      if (STARTED & ~rst_n_i) begin

         // Debug info
         $display("fftctl %1d: cycle_num = %1d", $time, cycle_num); 
         $display("fftctl %1d: fftctl_cycle_num_o = %1d", $time, fftctl_cycle_num_o); 
         $display("fftctl %1d: out2_offset = %1d", $time, out2_offset); 


         {BFLY0_op1_ix_o,BFLY0_op2_ix_o} <= GenOps2(cycle_num, 0, stageno);




         // And now for access type!
         // (Needed only for TRUE_1PORT.  Otherwise will be eliminated as unused...right?)
         // TODO: Make this conditional on SRAM_TYPE==TRUE_1PORT
         BFLY0_access_type_o <= BFLY0_access_type[cycle_num];

         // New bypass controls.
         suppress_wz_o <= precomputed_suppress_wz[cycle_num];
         bypass_read_o <= precomputed_bypass_read[cycle_num];

         bufnum_o[ 0] <= 1'b0;
         bufnum_o[ 1] <= 1'b0;
         bufnum_o[ 2] <= 1'b0;
         bufnum_o[ 3] <= 1'b0;

         // Debugging info
         $display("fftctl %1d: in(%2d,%2d), out(%2d, %2d)",$time, BFLY0_op1_ix_o, BFLY0_op2_ix_o, BFLY0_op1_ix_o, BFLY0_op2_ix_o);

         // out2_offset is used to generate op2 from a given precomputed op1
         if ((cycle_num & 3) == 3) begin
            out2_offset <= (out2_offset << 1);
            stageno     <= (stageno + 1'b1);
            $display("GENOPS2 (t=%06d) STAGE %1d", $time, stageno+1);
         end

         // Must make cycle_num available to twiddle LUT so as to generate the right twid at the right time.
         fftctl_cycle_num_o <= cycle_num;
         cycle_num          <= cycle_num + 1'b1;
         $display("fftctl %1d: cycle_num = %1d", $time, cycle_num); 
      end
   end

   always @(posedge fftclk_o) begin
     // LAST signal tells us when we're done.
     if (cycle_num == 12) LAST <= 1'b1;

      if (LAST==1) begin  // TODO probably don't need LAST somehow...
         // We're done, turn everything off.
         STARTED <= 1'b0;
             BFLY0_op1_ix_o <= {3{1'bx}}; // Turn off output, for pretty waveform end.  TODO what about in2, out[12]?
      end
  end
endmodule


/////////////////////////////////////////////////////////////////////////////////
// MIT License
// 
// Copyright (c) 2013 Stephen E. Richardson and Stanford University
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IM-
// PLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNEC-
// TION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
// 
// For more information please contact
// Stephen E. Richardson  steveri@stanford.edu (Stanford University)
// Prof. Mark Horowitz   horowitz@stanford.edu (Stanford University)
/////////////////////////////////////////////////////////////////////////////////
