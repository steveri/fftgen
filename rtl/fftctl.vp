//;# push (@INC, "./rtl"); # Now this happens when "Makefile.local" (sets PERL5LIB)
//; require fftgen;        # log2(), iterate()
//; require fft_scheduler; # Note fft_scheduler "requires" swizzler.pm
//;
// ---------------- Begin default Genesis2 parameter summary ----------------
//
//; # parameter() calls send default Genesis output to top of .v file
//;
//;# Note parameter declarations (below) will be summarized in the verilog.
//; my $npoints = parameter
//;    (Name=>'n_fft_points', Val=>16,
//;     Doc=>'Number of complex data values to process.');
//;
//; my $upc = parameter
//;    (Name=>'units_per_cycle', Val=>1.0, List=>[0.25, 0.5, 1.0, 2.0, 4.0],
//;     Doc=>'Number active butterfly units per cycle (.25 means one unit at 1/4 speed)');
//; 
//; my $SRAM_TYPE = parameter
//;    (Name=>'SRAM_TYPE', Val=>"TRUE_1PORT",
//;     List=>["TRUE_1PORT", "TRUE_2PORT", "1PORT_DBLPUMP"],
//;     Doc=>'What kind of SRAM should the FFT use?');
//;
// ---------------- End default Genesis2 parameter summary ----------------

////////////////////////////////////////////////////////////////////////
// module `mname`
//
// Usage: my $fftctl = generate('fftctl', 'fftctl'
//             , n_fft_points    => 1024
//             , units_per_cycle => 4
//             , SRAM_TYPE       => "1PORT_DBLPUMP"
//             );
//
// Where (default value is starred)
//   "n_fft_points"    can be any power of two greater than 8 (16*)
//   "units_per_cycle" can be 0.25, 0.5, 1.0*, 2.0 or 4.0
//   "SRAM_TYPE"       is either "1PORT_DBLPUMP" or "TRUE_1PORT"* (or "TRUE_2PORT")
//
// *default
//
// Example(s):  see above.

////////////////////////////////////////////////////////////////////////
// Parameter values used by this instantiation:
//; foreach my $p (@{$self->{ParametersList}}) {
//;     my $val = $self->{Parameters}->{$p}->{Val};
//;     my $doc = $self->{Parameters}->{$p}->{Doc};
//;     printf("//     %-24s %s\n", "$p ($val)", $doc);
//; }
//
//;##############################################################################
//; my $n_sram_ports = ($SRAM_TYPE eq "TRUE_1PORT") ? 1 : 2;
//; # my $inbuf_ptr = 0;
//; # my $outbuf_ptr = 0;
//; my $timestep = 1;
//; my $nunits   = 1;
//; 
//; if ($upc <= 1.0) {
//;     $timestep = 1/$upc;
//;     printf("// Building ONE butterfly unit\n");
//;     printf("// local_clock = global_clock/%d\n", 1/$upc);
//; }
//; else {
//;     $nunits = $upc;
//;     printf("// Building %d butterfly units\n", $upc);
//;     printf("// local_clock = global_clock\n", 1/$upc);
//; }
//; 
//
// Derived values:
//    $timestep (`$timestep`) = time it takes (cycles) for butterfly unit to complete one operation
//    $nunits   (`$nunits`)   = number of butterfly units we have to build (four maximum)
//
//;# $self->{nunits} = $nunits;  # Make nunits available to others.
//;#
//; my $nlevels = fftgen::log2($npoints);            
//; my $ncalcs_per_unit = ($nlevels * ($npoints/2))/$nunits;
//; if ($nunits > 4) { print "\n\nERROR (fftctl.vp): Too many butterfly units ($nunits > 4)\n\n"; }
//    $nlevels  (`$nlevels`)  = levels (columns) in the (virtual) bfly network
//    $ncalcs_per_unit (`$ncalcs_per_unit`) = total ncalcs to be performed by each bfly unit

//;##############################################################################
//;# Create a complete conflict-free memory access schedule for the FFT.
//;# "Reschedule" (for 1port ram) means to use one or more bypass buffers.
//;#
//;# Is this sttmt actually CREATING @fft_scheduler::fft_sched?
//;# Without a "my" keyword e.g.?  Can it DO that???
//; if ($n_sram_ports == 2) {
//;   @fft_scheduler::fft_sched = fft_scheduler::fft_schedule($npoints, $nunits, "", "");
//; } else {
//;   @fft_scheduler::fft_sched = fft_scheduler::fft_schedule($npoints, $nunits, "reschedule", "");
//; }
//;#
//;# //; for (my $i=0; $i <  @fft_scheduler::fft_sched; $i++) {
//;# //;     
//;# //;     my $bufnum1 = @fft_scheduler::fft_sched[$i]->{op1_buffer};
//;# //;     my $bufnum2 = @fft_scheduler::fft_sched[$i]->{op2_buffer};
//;# //;     my $bufacc1 = @fft_scheduler::fft_sched[$i]->{op1_buffer_access};
//;# //;     my $bufacc2 = @fft_scheduler::fft_sched[$i]->{op2_buffer_access};
//;# //;     
//;# //;     printf("//FOOG $i op1_buffer=$bufnum1 op2_buffer=$bufnum2 ".
//;# //;            "op1_buffer_access=$bufacc1 op2_buffer_access=$bufacc2\n");
//;# //; }
//;
//;########################################################################
//; # Port signals will be used in several different places...
//; # (So put them in reusable arrays!)
//;
//; my @inputs = (
//;     "", "clk", "  // Clock",
//;     "", "rst_n", "// Reset signal per power-up",
//;     "", "start", "// Start signal per FFT",
//; );
//;
//; my @butterfly_unit_indices = build_butterfly_unit_indices();
//;
//; my @atype_output = build_access_type_array();
//; # E.g. ("blank", "",                  "// Per-butterfly access type\n",
//; #       "[2:0]", "BFLY0_access_type", "",
//; #       "[2:0]", "BFLY1_access_type", "",
//; #       "[2:0]", "BFLY2_access_type", "",
//; #       "[2:0]", "BFLY3_access_type", "",
//; #       "[2:0]", "BFLY0_access_type", "")
//;
//; my $cnbits = sprintf("[%d:0]", fftgen::log2($ncalcs_per_unit)-1);  # Weird?  Contrived?
//; my @outputs = (
//;     $cnbits, "fftctl_cycle_num", "// 0, 1, 2, ...",
//;     "     ",      "busy",           "         // hi while busy computing fft",
//;     "     ",      "fftclk",   sprintf("         // local_clk = global_clk/%d",$timestep) # FIXME/TODO/BUG never used??
//; );
//;
//; ########################################################################
//; # Controls for bypass buffer.  E.g.:
//; #    output logic [nbanks:0] suppress_wz_o; // {0,1}
//; #    output logic [nbanks:0] bypass_read_o; // {0,1}
//; #    output logic [0:1] bufnum_o[0:nbanks]; // {0,1,2,3}
//;
//; # I think these are only used when nunits==1
//; # FIXME either make it conditional on nunits==1 or use for all cases!
//; my $nbanks   = 4*$nunits;
//; my $lastbank = $nbanks-1;
//; # if 4 units, use 4 buffers, otherwise only need two (or one).
//; my $bufbits  = ($nunits == 4) ? "[1:0]" : "     ";
//; @outputs = (@outputs
//;     , "blank", "", "\n"
//;     , "blank", "", "// Bypass controls\n"
//;     , "[$lastbank:0]", "suppress_wz", " // one bit per bank, set 100 ps after posedge"
//;     , "[$lastbank:0]", "bypass_read", " // one bit per bank, set 100 ps after posedge"
//;     , "$bufbits", "bufnum[0:$lastbank]", "          // which buffer do we use for bypass (per bank)?"
//; );
//;
//; ####################################################################
//; # Generate submodules.
//; #
//; my $lclock = generate('fftclock','LCLK', DIV=>$timestep); # Divide by two
//; 
//; ####################################################################
//; # Verilog code starts here:
//;
////////////////////////////////////////////////////////////////////////
// Will produce `$nlevels` levels (columns) in the (virtual) butterfly network.

module `mname`
  (
   //;   printwires("      ", "io_list");  # List of inputs and outputs.
   );
   //////////////////////////////////////////////////////////////////////////////
   // DECLARATIONS
   // Will use iterated op1_mem values to initialize reg file index values:
   //;    gen_op1_mem_decl();

   // Will iterate on precomputed 'access_type' registers to control
   // bypassing.  *****Only used for 1port SRAM when nunits==1.*****
   //;    gen_access_type_decl();

   // For nunits>1, use precomputed bit vectors to control bypass buffers.
   // Each register has one bit per SRAM (i.e. four bits per butterfly unit),
   // to tell which (up to four) SRAM's are being bypassed in this cycle.
   // E.g. suppress_wz = "0000 0000 0000 0011" means that the writes destined
   // for SRAM001 and SRAM000 should go to bypass buffers instead.  "Bufnum"
   // tells which of up to four bypass buffers hold this data, thus "bufnum"
   // needs two bits per SRAM access.

   //;# my $nops = ($nunits * $ncalcs_per_unit) - 1;
   //; my $nops = $ncalcs_per_unit - 1;
   //; my $bufbits = ($nunits == 4) ? "[0: 1]" : "     ";
   logic [0:`$lastbank`] precomputed_suppress_wz [0:`$nops`];      // {0,1}
   logic [0:`$lastbank`] precomputed_bypass_read [0:`$nops`];      // {0,1}
   logic `$bufbits` precomputed_bufnum[0:`$lastbank`][0:`$nops`];      // {0,1,2,3}

   // Need to count through array(s) from 0 to `$ncalcs_per_unit-1`
   // May need to count a cycle or two beyond minimum!  (Why?)
   logic [`fftgen::log2($ncalcs_per_unit)`:0] cycle_num;

   // out2_offset is used to calculte op2 from op1.\n");
   logic [`fftgen::log2($npoints)`:0] out2_offset;

   // Control signals.
   logic       STARTED;
   logic       LAST;
   //////////////////////////////////////////////////////////////////////////////////////
   // INIT BLOCKS

   initial begin
      cycle_num   <= 0;
      STARTED     <= 0;
      LAST        <= 1;
      out2_offset <= 1;
   end

   initial begin
      // Precompute values for op1 index "op1_ix_mem"
      // {(0,2,4,...) (0,4,8,...1,5,9,...) (0,8,16,...1,9,17...) ... (0,1,2,3,...n/2)
      //; # E.g. for n=8
      //; #    /***************** Stage 0: ******************/
      //; #    BFLY0_op1_ix_mem[ 0] =  0;    // indices (0,1)
      //; #    BFLY0_op1_ix_mem[ 1] =  2;    // indices (2,3)
      //; #    BFLY0_op1_ix_mem[ 2] =  4;    // indices (4,5)
      //; #    BFLY0_op1_ix_mem[ 3] =  6;    // indices (6,7)
      //; #
      //; #     /***************** Stage 1: ******************/
      //; #    BFLY0_op1_ix_mem[ 4] =  0;    // indices (0,2)
      //; #    BFLY0_op1_ix_mem[ 5] =  4;    // indices (4,6)
      //; #    BFLY0_op1_ix_mem[ 6] =  1;    // indices (1,3)
      //; #    BFLY0_op1_ix_mem[ 7] =  5;    // indices (5,7)
      //;              
      //;    gen_op1_mem_values("   ");

      //; # E.g. for each cycle [0] through [n]:
      //; #  precomputed_suppress_wz[0] = 16`h01; # Write to  buffer[bufnum[0]] instead of SRAM000
      //; #  precomputed_bypass_read[0] = 16`h02; # Read from buffer[bufnum[1]] instead of SRAM001
      //; #  
      //; #  precomputed_bufnum[7][0] = 2'h0;
      //; #  precomputed_bufnum[6][0] = 2'h0;
      //; #  precomputed_bufnum[5][0] = 2'h0;
      //; #  precomputed_bufnum[4][0] = 2'h0;
      //; #  precomputed_bufnum[3][0] = 2'h0;
      //; #  precomputed_bufnum[2][0] = 2'h0;
      //; #  precomputed_bufnum[1][0] = 2'h3;
      //; #  precomputed_bufnum[0][0] = 2'h2;
      //;              
      //;    gen_precomputed_bypass_controls("   ");
   end

   //////////////////////////////////////////////////////////////////////////////////////
   // Initialize iterator for op1_ix_mem

   always @(posedge start_i) if (~rst_n_i) begin
      cycle_num   <= 0;
      STARTED     <= 1;
      LAST        <= 0;
      out2_offset <= 1;
      suppress_wz_o <= 0;
   end

   assign busy_o = ~LAST;

   //////////////////////////////////////////////////////////////////////////////////////
   // Generate local clock fftclk_o from global clock gclk
   // TODO: would feel better if divisor was passed in as a parameter rather than generated cross-module...?
   // TODO: if $upc==1 could maybe replace this with an ASSIGN
   `$lclock->instantiate()`(.clock_in(clk_i), .clock_out(fftclk_o));

   //////////////////////////////////////////////////////////////////////////////////////
   // Fetch and deliver precomputed ops and bypass info on a per-cycle basis.



   always @(posedge fftclk_o) begin
      if (STARTED & ~rst_n_i) begin

         // Debug info
         $display("fftctl %1d: cycle_num = %1d", $time, cycle_num); 
         $display("fftctl %1d: fftctl_cycle_num_o = %1d", $time, fftctl_cycle_num_o); 
         $display("fftctl %1d: out2_offset = %1d", $time, out2_offset); 

         // Retrieve precomputed op1 operands for each butterfly unit BFLY<i>
         //; for (my $i = 0; $i < $nunits; $i++) {   
         BFLY`${i}`_op1_ix_o <= BFLY`${i}`_op1_ix_mem[cycle_num];
         //; }

         // Use precomputed op1 to calculate op2
         //;# BFLY0_op2_ix_o = BFLY0_op1_ix_o + out2_offset;
         //;# BFLY1_op2_ix_o = BFLY1_op1_ix_o + out2_offset;
         //;# ...
         //; for (my $i = 0; $i < $nunits; $i++) {
         BFLY`${i}`_op2_ix_o <= BFLY`${i}`_op1_ix_mem[cycle_num] + out2_offset;
         //; }

         // And now for access type!
         // (Needed only for TRUE_1PORT.  Otherwise will be eliminated as unused...right?)
         // TODO: Make this conditional on SRAM_TYPE==TRUE_1PORT
         //; for (my $i = 0; $i < $nunits; $i++) {   
         BFLY`${i}`_access_type_o <= BFLY`${i}`_access_type[cycle_num];
         //; }

         // New bypass controls.
         suppress_wz_o <= precomputed_suppress_wz[cycle_num];
         bypass_read_o <= precomputed_bypass_read[cycle_num];

         //; my $nbanks = $nunits * 4;
         //; for (my $i=0; $i<$nbanks; $i++) {
         //;     my $ii = sprintf("%2d", $i);
         //;     if ($nunits == 1) {
         bufnum_o[`$ii`] <= 0;
         //;     } else {
         bufnum_o[`$ii`] <= precomputed_bufnum[`$ii`][cycle_num];
         //;     }
         //; }

         // Debugging info
         //;    for (my $i = 0; $i < $nunits; $i++) {   
         $display("fftctl %1d: in(%2d,%2d), out(%2d, %2d)",$time, BFLY`$i`_op1_ix_o, BFLY`$i`_op2_ix_o, BFLY`$i`_op1_ix_o, BFLY`$i`_op2_ix_o);
         //;    }

         // out2_offset is used to generate op2 from a given precomputed op1
         //; my $calcs_per_level = $npoints/2;              
         //; my $ncy_per_level = $calcs_per_level/$nunits;  
         if ((cycle_num & `($ncy_per_level-1)`) == `($ncy_per_level-1)`) begin
            out2_offset <= (out2_offset << 1);
         end

         // Must make cycle_num available to twiddle LUT so as to generate the right twid at the right time.
         fftctl_cycle_num_o <= cycle_num;
         cycle_num          <= cycle_num + 1;
         $display("fftctl %1d: cycle_num = %1d", $time, cycle_num); 
      end
   end

   //;# TODO: Clean up stupid "LAST" signal.
   always @(posedge fftclk_o) begin
     // LAST signal tells us when we're done.
     //; my $last_cycle = $ncalcs_per_unit + 1;             # Need one extra cycle to complete (why?)
     //; if ($SRAM_TYPE eq "TRUE_1PORT") { $last_cycle++; } # Plus one cycle for the final write.
     //;
     if (cycle_num == `$last_cycle-1`) LAST <= 1;

      if (LAST==1) begin  // TODO probably don't need LAST somehow...
         // We're done, turn everything off.
         STARTED <= 0;
         //; for (my $i = 0; $i < $nunits; $i++) {
             BFLY`$i`_op1_ix_o <= 'X; // Turn off output, for pretty waveform end.  TODO what about in2, out[12]?
         //; }
      end
  end
endmodule

//; ##############################################################################
//; # Local subroutines.
//; #
//; sub printconnections {
//;     my $indent = shift @_;
//;     my $indent = "      ";
//; 
//;     # Print a beautiful list of port connections for an instance.
//;     # Used by e.g. "top_fft.vp" to connect to "fftctl.vp"; i.e. "top_fft.vp"
//;     # will call "fftctl->printconnections" to connect to "fftctl".
//;     #     .clk(clk_i),
//;     #     .rst_n(rst_n_i), etc.
//; 
//;     print $indent."// begin fftctl->printconnections()\n";
//; 
//;     # First print connections to inputs listed in "@inputs" array.
//;     for (my $i = 0; $i < @inputs; $i += 3) {
//;         if ($inputs[$i] eq "blank") {
//;             print $indent.$inputs[$i+2];    # "blank" => skip a line in the portlist.
//;         } else {
//;             fftgen::printparm($indent, $inputs[$i+1], "_i", $inputs[$i+2], 0);
//;         }
//;     }
//;     print "\n";
//;     print $indent."// Indices for where bfly should fetch from array of data point\n";
//;     for (my $i=0; $i<$nunits; $i++) {
//;             printf("$indent.BFLY${i}_op1_ix_o(BFLY${i}_op1_ix),\n");    # .BFLY0_op1_ix_o(BFLY0_op1_ix),
//;             printf("$indent.BFLY${i}_op2_ix_o(BFLY${i}_op2_ix),\n");    # .BFLY0_op2_ix_o(BFLY0_op2_ix),
//;             print "\n";
//;     }
//;     print "\n";
//;     print $indent."/////////////////////////////////////////////////////////////////////\n";
//;     print $indent.'// Access type: 0="SRAM"'."\n";
//;     print $indent.'// 1="op1 from buf", 2="op2 from buf", 3="op1 to buf", 4="op2 to buf"'."\n";
//;     print "\n";
//;     for (my $i=0; $i<$nunits; $i++) {
//;         printf("$indent.BFLY${i}_access_type_o(BFLY${i}_access_type),\n"); # .BFLY0_access_type_o(BFLY0_access_type),
//;     }
//;     print "\n";
//;     print "\n";
//; 
//;     # TODO Could easily merge this "output" routine w/ the "input" routine above.
//;     print $indent.'// Other output signals'."\n";
//;     print "\n";
//;     my $n_outputs = @outputs;                    # No. items in array "@outputs"
//;     for (my $i = 0; $i < $n_outputs; $i += 3) {
//;         if ($outputs[$i] eq "blank") {
//;             print $indent.$outputs[$i+2];    # "blank" => skip a line in the portlist.
//;         } else {
//;             #my $no_comma = "";
//;             #if ($i == ($n_outputs - 3)) { $no_comma = "no_comma"; }
//; 
//;             # !!$? Last item in list must have "no comma."
//;             my $no_comma = ($i == ($n_outputs - 3)) ? "no_comma" : "";
//; 
//;             # Strip off the bit specs and add a "_o", e.g.
//;             #   "mywires"     => ".mywires_o(mywires)" and
//;             #  "mywires[0:n]" => ".mywires_o(mywires)"
//;             my $wirename = $outputs[$i+1];
//;             if ($wirename =~ /(.*)(\[.*)/) { $wirename = $1; }
//;             fftgen::printparm($indent, $wirename, "_o", $outputs[$i+2], $no_comma);
//;         }
//;     }
//;    print "\n";
//;    print $indent."// end fftctl->printconnections()\n";
//; }
//; 
//; sub printwires {
//;    # Okay yes this is weird but parm list has extra "HASH" when called as "function()" vs. "obj->function()"!!
//;    my $indent = shift @_; while ($indent =~ /HASH/) { $indent = shift @_; }
//;    my $list    = shift @_; # Either "io_list" (for me) or "wire_list" (for others)
//;    my $io_list = ($list eq "io_list") ? 1 : 0;
//;    
//;    # Print port list as either list of wires ($list="wire_list")
//;    # or list of inputs and outputs           ($list="io_list")
//;    # Called by self (above) to print io's; called by e.g. "top_fft"
//;    # to build list of wires to connect to fftctl io ports.
//; 
//;    print $indent."//------------------------------------------------\n";
//;    print $indent."// begin fftctl->printwires('$indent', '$list')\n\n";
//; 
//;    # Print inputs.  If "$io_list" true, add "input" and comma, e.g.:
//;    #   input logic  clk_i,   // Clock
//;    #   input logic  rst_n_i, // Reset signal per power-up
//;    #   input logic  start_i, // Start signal per FFT
//;    pw($indent, $io_list, "input", @inputs, "not_last");
//; 
//;    # Butterfly unit operands, e.g.
//;    #   output logic [2:0] BFLY0_op1_ix_o, 
//;    #   output logic [2:0] BFLY0_op2_ix_o, 
//;    pw($indent, $io_list, "output", @butterfly_unit_indices, "not_last");
//; 
//;    # Bypass control signals
//;    pw($indent, $io_list, "output", @atype_output, "not_last");
//; 
//;    print $indent."// Remaining output signals\n";
//;    #   output logic [2:0] fftctl_cycle_num_o, // 0, 1, 2, ...
//;    #   output logic  busy_o,   // hi while busy computing fft
//;    #   output logic  fftclk_o // local_clk = global_clk/1
//;    pw($indent, $io_list, "output", @outputs, "last");
//; 
//;    print $indent."// end fftctl->printwires()\n";
//;    print $indent."//------------------------------------------------\n";
//; }
//; 
//; sub pw {
//;
//;     ########################################################################
//;     # Printwires helper function pw().
//;     # Usage:    pw($indent, $io_list, $io_type, @signals, $last);
//;     # Example:  pw($indent, $io_list, "input", @inputs, "not_last");
//;     #
//;     # Print wires as indicated in array @signals.
//;     #  If "$io_list" true, add "input" and comma (if not "last"), e.g.:
//;     #   input logic  clk_i,   // Clock
//;     #   input logic  rst_n_i, // Reset signal per power-up
//;     #   input logic  start_i, // Start signal per FFT
//;
//;     my $last = pop @_; # "last" or anything else (e.g. "notlast")
//; 
//;     my $indent  = shift @_;
//;     my $io_list = shift @_;  # 1 or 0
//;     my $io_type = shift @_;  # "input" or "output"
//;     my @signals = @_;
//; 
//;     for (my $i = 0; $i < @signals; $i += 3) {
//;         
//;         my $bits    = $signals[$i+0];  # E.g. "[3:0]"
//;         my $signame = $signals[$i+1];  # E.g. "fourbit_counter"
//;         my $comment = $signals[$i+2];  # E.g. "// Counts to sixteen"
//;         
//;         if ($bits eq "blank") {
//;             print $indent.$comment; # (newline char must be embedded in comment!)
//;             next;
//;         }
//;         if (! $io_list) {
//;             # Simple wire list e.g. "logic mywires[0:15];"
//;             printf($indent."logic %s %s; %s\n", $signals[$i], $signals[$i+1], $signals[$i+2]);
//;         }
//;         else {
//;             # IO wire list e.g.
//;             #     "mywires"      => "input logic mywires_i,"     or
//;             #     "mywires[0:n]" => "input logic mywires_i[0:n],"
//;             my ($aye,$oh) = ("_i","_o");
//;
//;             # E.g. ""mywires[0:15]" => ("mywires", "_i[0:15]", "_o[0:15")
//;             if ($signame =~ /(.*)(\[.*)/) { ($signame,$aye,$oh) = ($1, "_i".$2, "_o".$2); }
//;             
//;             my $comma  = "," ;
//;             if (($last eq "last") && ($i == (@signals - 3))) { $comma = ""; } # No comma on last item
//;             
//;             if ($io_type eq "input") {
//;                 printf($indent."input logic $bits ${signame}$aye$comma $comment\n");
//;             } else {
//;                 printf($indent."output logic $bits ${signame}$oh$comma $comment\n");
//;             }
//;         }
//;     }
//;     print "\n";
//; }
//; 
//; sub gen_op1_mem_decl {
//;     #################################################################
//;     # Declare the memory that will hold precomputed op1 values.  E.g.
//;     #     logic [3:0] BFLY0_op1_ix_mem [0:7];
//;     #     logic [3:0] BFLY1_op1_ix_mem [0:7];
//; 
//;     my $indent   = "   ";
//;     my $bitwidth = fftgen::log2($npoints); # Need to hold values [0..($npoints-2)]
//;     printf($indent."// $bitwidth-bit wide registers hold op1 values ranging from 0 to npoints=%d\n", $npoints-1);
//;     printf($indent."// $ncalcs_per_unit registers per butterfly unit, one for each computation cycle.\n");
//;     printf($indent."\n");
//;     for (my $i=0; $i<$nunits; $i++) {
//;         printf($indent."logic [%d:0] BFLY%d_op1_ix_mem [0:%d];\n", $bitwidth-1, $i, $ncalcs_per_unit-1);
//;     }
//;   }
//;    
//; sub gen_access_type_decl {
//;     #################################################################
//;     # Declare the memory that will hold precomputed access_type values.  E.g.
//;     #     logic [2:0] BFLY0_access_type [0:7];
//;     #     logic [2:0] BFLY1_access_type [0:7];
//; 
//;     my $indent   = "   ";
//;     print $indent."// Three-bit registers hold one of five access types:\n";
//;     print $indent.'// ("SRAM", "op1 from buf", "op2 from buf", "op1 to buf", "op2 to buf")'."\n";
//;     print "\n";
//;     for (my $i=0; $i<$nunits; $i++) {
//;         printf($indent."logic [2:0] BFLY%d_access_type [0:%d];\n", $i, $ncalcs_per_unit-1);
//;     }
//;   }
//;    
//; sub gen_op1_mem_values {
//;     my $indent = shift;
//;     
//;     # Precompute values for op1 index "op1_ix_mem"
//;     #{(0,2,4,...) (0,4,8,...1,5,9,...) (0,8,16,...1,9,17...) ... (0,1,2,3,...n/2)
//;     # E.g. for n=8
//;     #    /***************** Stage 0: ******************/
//;     #    BFLY0_op1_ix_mem[ 0] =  0;    // indices (0,1)
//;     #    BFLY0_op1_ix_mem[ 1] =  2;    // indices (2,3)
//;     #    BFLY0_op1_ix_mem[ 2] =  4;    // indices (4,5)
//;     #    BFLY0_op1_ix_mem[ 3] =  6;    // indices (6,7)
//;     #
//;     #     /***************** Stage 1: ******************/
//;     #    BFLY0_op1_ix_mem[ 4] =  0;    // indices (0,2)
//;     #    BFLY0_op1_ix_mem[ 5] =  4;    // indices (4,6)
//;     #    BFLY0_op1_ix_mem[ 6] =  1;    // indices (1,3)
//;     #    BFLY0_op1_ix_mem[ 7] =  5;    // indices (5,7)
//; 
//;     my $unum = 0;
//;     my $bfly_ix = 0;
//;     my $prev_stage = -1;
//;     for (my $i=0; $i <  @fft_scheduler::fft_sched; $i++) {
//;         my $stage = @fft_scheduler::fft_sched[$i]->{stage};
//;         if ($stage != $prev_stage) {
//;             print $indent."\n";
//;             printf("$indent    /***************** Stage $stage: ******************/\n");
//;             $prev_stage = $stage;
//;         }
//;         my $op1 = @fft_scheduler::fft_sched[$i]->{op1};
//;         my $op2 = @fft_scheduler::fft_sched[$i]->{op2};
//;         
//;         printf("$indent    BFLY%d_op1_ix_mem[%2d] = %2d;", $unum, $bfly_ix, $op1);
//;         printf("    // indices (%d,%d)\n", $op1, $op2);
//;         if (($unum == ($nunits-1)) && ($nunits > 1)) { print "\n"; }
//;         
//;         $unum = ($unum + 1) % $nunits;   # 0,1,2,3, 0,1,2,3, ...
//;         if ($unum == 0) { $bfly_ix++; }  # 0,0,0,0, 1,1,1,1, ...
//;     }
//; }
//; 
//; sub gen_precomputed_bypass_controls {
//;     my $indent = shift;
//; 
//;      print "$indent   /////////////////////////////////////////////////////////////////////////////\n";
//;      print "$indent   // Note: for nunits==1 suppress_wz and bypass_read are one-hot\n";
//; 
//;      # precomputed_suppress_wz[0] = 16`h01; # Write to buffer[bufnum[0]] instead of SRAM000
//;      # precomputed_bypass_read[0] = 16`h02; # Read from buffer[bufnum[1]] instead of SRAM001
//;      # 
//;      #   // For nunits>1 only (otherwise bufnum always == 0)
//;      #   precomputed_bufnum[7][0] = 2'h0;
//;      #   precomputed_bufnum[6][0] = 2'h0;
//;      #   precomputed_bufnum[5][0] = 2'h0;
//;      #   precomputed_bufnum[4][0] = 2'h0;
//;      #   precomputed_bufnum[3][0] = 2'h0;
//;      #   precomputed_bufnum[2][0] = 2'h0;
//;      #   precomputed_bufnum[1][0] = 2'h3;
//;      #   precomputed_bufnum[0][0] = 2'h2;
//;     
//;      my $cynum = 0;
//;      my $prev_stage = -1; 
//;      for (my $cynum=0; $cynum <  @fft_scheduler::fft_sched/$nunits; $cynum++) {
//;
//;         my $stage = @fft_scheduler::fft_sched[$cynum]->{stage};
//;         if ($stage != $prev_stage) {
//;             print "\n";
//;             print $indent."    /***************** Stage $stage: ******************/\n";
//;             $prev_stage = $stage;
//;         }
//;
//;         # $read_op     # Bit vector of all writes for a given cycle
//;         # $write_op    # Bit vector of all reads for a given cycle
//;         # @bufnums     # Array of bufnums for a given cycle (iff nunits>1)
//;         my ($read_op, $write_op, @bufnums) = build_access_vectors($cynum, $nunits);
//; 
//;         printf("$indent    precomputed_suppress_wz[%2d] = %d'h%02X;\n", $cynum, $nbanks, $write_op);
//;         printf("$indent    precomputed_bypass_read[%2d] = %d'h%02X;\n", $cynum, $nbanks, $read_op);
//;         if ($nunits>1) {
//;             print "\n";
//;             my $nbanks = 4*$nunits;
//;             for (my $b=0; $b<$nbanks; $b++) {
//;                 printf("$indent    precomputed_bufnum[%2d][%2d] = 2'h%d;\n", $b, $cynum, $bufnums[$b]);
//;             }
//;             print "\n";
//;         }
//;     }
//; }
//; 
//; sub build_access_vectors {
//;    my $cynum = shift;
//;    my $nunits = shift;
//; 
//;    ########################################################################
//;    # For given cycle $cynum in the schedule, query the previously-initialized
//;    # data structure fft_sched and build <nunits>
//;    # access control vectors (one per butterfly unit) that will tell us when to bypass SRAM's.
//; 
//;    my $i = $cynum * $nunits; # Each cycle produces <nunits> ops, one per butterfly.
//;
//;    my $read_op  = 0;    # Bit vector of all writes for a given cycle
//;    my $write_op = 0;    # Bit vector of all reads for a given cycle
//;    my @bufnums  = ();   # Array of bufnums for a given cycle (iff nunits>1)
//; 
//;    for (my $bfly = 0; $bfly < $nunits; $bfly++) {
//;        my $bank1 = @fft_scheduler::fft_sched[$i]->{bank1};
//;        my $bank2 = @fft_scheduler::fft_sched[$i]->{bank2};
//;        if ($nunits == 1) {
//; 
//;            my $access = @fft_scheduler::fft_sched[$i]->{access};
//;            
//;            # Only one of the following will be true...right?  RIGHT!  Duh.
//;            if ($access eq "op1 from buffer") { $read_op  |= 2**$bank1; }
//;            elsif ($access eq "op2 from buffer") { $read_op  |= 2**$bank2; }
//;            elsif ($access eq  "op1 to buffer")  { $write_op |= 2**$bank1; }
//;            elsif ($access eq  "op2 to buffer")  { $write_op |= 2**$bank2; }
//;        }
//;        else {
//;            # $fft_info[$fftno]->{op[12]_buffer}        = -1 or (0, 1, 2, 3)
//;            # $fft_info[$fftno]->{op[12]_buffer_access} = ("RD", "WR", "NONE", or "BOTH")
//;            
//;            my $bufnum1 = @fft_scheduler::fft_sched[$i]->{op1_buffer};
//;            my $bufnum2 = @fft_scheduler::fft_sched[$i]->{op2_buffer};
//;            my $bufacc1 = @fft_scheduler::fft_sched[$i]->{op1_buffer_access};
//;            my $bufacc2 = @fft_scheduler::fft_sched[$i]->{op2_buffer_access};
//;            
//;            # //; printf("//FOOG $i op1_buffer=$bufnum1 op2_buffer=$bufnum2 ".
//;            # //;        "op1_buffer_access=$bufacc1 op2_buffer_access=$bufacc2\n");
//;
//;            if ($bufacc1 eq "RD" || $bufacc1 eq "BOTH") { # Really?  BOTH??
//;                $read_op  |= 2**$bank1; $bufnums[$bank1] = $bufnum1; }
//;            if ($bufacc1 eq "WR" || $bufacc1 eq "BOTH") {
//;                $write_op |= 2**$bank1; $bufnums[$bank1] = $bufnum1; }
//; 
//;            if ($bufacc2 eq "RD" || $bufacc2 eq "BOTH") {
//;                $read_op  |= 2**$bank2; $bufnums[$bank2] = $bufnum2; }
//;            if ($bufacc2 eq "WR" || $bufacc2 eq "BOTH") {
//;                $write_op |= 2**$bank2; $bufnums[$bank2] = $bufnum2; }
//;        }
//;        $i++;
//;    }
//;    return ($read_op, $write_op, @bufnums);
//; }
//; 
//; sub build_butterfly_unit_indices {
//;
//;     # Build array of info for constructing wires and io ports, e.g.
//;     # (
//;     #   "blank", "", "// Butterfly unit operands\n",  # Title of the list
//;     #   "[4:0]", "BFLY0_op1_ix_o", "",
//;     #   "[4:0]", "BFLY0_op2_ix_o", ""
//;     # )
//;
//;     my $nbits = fftgen::log2($npoints);
//;     my $bitrange = sprintf("[%d:0]", $nbits-1);
//;     my @oplist = (
//;         "blank", "", "// Butterfly unit operands\n"
//;         );
//;     for (my $i=0; $i<$nunits; $i++) {
//;         push(@oplist, ($bitrange, "BFLY${i}_op1_ix", ""));
//;         push(@oplist, ($bitrange, "BFLY${i}_op2_ix", ""));
//;         if ($nunits > 1) { push(@oplist, ("blank", "", "\n")); }
//;     }
//; #     if ($nunits == 1) { push(@oplist, ("blank", "", "\n")); }
//;     return @oplist;
//; }
//; 
//; sub build_access_type_array {
//;     # E.g.   ("blank", "", "// Per-butterfly access type\n",
//;     #         "[2:0]", "BFLY0_access_type", "",
//;     #         "[2:0]", "BFLY1_access_type", "",
//;     #         "[2:0]", "BFLY2_access_type", "",
//;     #         "[2:0]", "BFLY3_access_type", "",
//;     #         "[2:0]", "BFLY0_access_type", "")
//; 
//;     my $nbits = fftgen::log2($npoints);
//;     my $bitrange = "[2:0]";
//;     my @oplist = ("blank", "", "// Per-butterfly access type\n");
//;     for (my $i=0; $i<$nunits; $i++) {
//;         push(@oplist, ($bitrange, "BFLY${i}_access_type", ""));
//; #         if ($nunits > 1) { push(@oplist, ("blank", "", "\n")); }
//;     }
//;     return @oplist;
//; }
