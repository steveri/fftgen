Notes:
  where is (READ buf)?

==============================================================================
1port:

continuous
  SRAM: addr_i = f(op1_ix)
  SRAM: rd_data_o = mem[addr_i]; if(~ez & wz)                (READ sram)

pos
  fftctl: op1_ix            <= mem[cynum]
  fftctl: atype             <= mem[cynum]
  fftctl: suppress_wz_100_o <= mem[cynum]
  fftctl: bypass_read_100_o <= mem[cynum]
  fftctl: bufnum_100_o      <= mem[cynum]
  fftctl: cynum++

  fftram: sram_wz <= f(clk,banknum)(***)           (if op matches banknum) (***)

  fftram: buf[bufnum_100_i] <= sram_wr_data (bfly_out_data)     (if suppress_wz_100) (WRITE buf)

  SRAM: mem[addr_i] = wr_data_i (bfly_out_data);          (WRITE sram)

neg:
  display info in SRAM

==============================================================================
dpump:

continuous
  SRAM: addr_i = f(op1_ix)

pos
  fftctl: op1_ix  <= mem[cynum]
  fftctl: atype   <= mem[cynum]
  fftctl: suppress_wz_100_o <= mem[cynum]
  fftctl: bypass_read_100_o <= mem[cynum]
  fftctl: bufnum_100_o      <= mem[cynum]
  fftctl: cynum++

  fftram: sram_wz <= f(banknum)(***)           (if op matches banknum) (***)

  SRAM: mem[addr_i] = wr_data_i (bfly_out_data);
  fftram: buf[bufnum_100_i] <= sram_wr_data (bfly_out_data)     (if suppress_wz_100)

  SRAM: mem[addr_i] = wr_data_i (bfly_out_data);  (WRITE sram)

neg
  fftram: sram_wz <= f(banknum)           (if op matches banknum)(***)
  SRAM: rd_data_o = mem[addr_i] (~ez & wz)                 (READ sram)

BOTH
  fftram: sram_wz <= f(banknum)           (if op matches banknum) (***)

==============================================================================
2port:

continuous
  SRAM: addr_i = f(op1_ix)
  SRAM: rd_data_o = mem[addr_i]; (~ez)                (READ sram)

pos
  fftctl: op1_ix  <= mem[cynum]
  fftctl: atype   <= mem[cynum]
  fftctl: suppress_wz_100_o <= mem[cynum]
  fftctl: bypass_read_100_o <= mem[cynum]
  fftctl: bufnum_100_o      <= mem[cynum]
  fftctl: cynum++

  fftram: sram_wz <= f(banknum)(***)           (if op matches banknum) (***)

  SRAM: mem[addr_i] = wr_data_i (bfly_out_data);
  fftram: buf[bufnum_100_i] <= sram_wr_data (bfly_out_data)     (if suppress_wz_100)

  SRAM: mem[addr_i] = wr_data_i (bfly_out_data);  (WRITE sram)

neg
  fftram: sram_wz <= f(banknum)           (if op matches banknum)(***)
  SRAM: rd_data_o = mem[addr_i] (~ez & wz)                 (READ sram)

BOTH
  fftram: sram_wz <= f(banknum)           (if op matches banknum) (***)


==============================================================================





  display("op1_ix maps to op1_addr(bank,row)")
  sram_addr <= op1_addr

pos+100
  op1_ix = next_op1_ix


neg:
  sram_read op1  to op1_addr
  sram_write op1 to sram_addr
  bbuf_write op1 to n

==============================================================================
NOW (1port):

ix (fftctl) changes on (posedge fftclk)+100                  ( 600,1600,2600...

"top_fft 1500: BFLY0_op1 ix 00 comes from bank  0 row   0"
before: display on (posedge fftclk)                          (1500,2500,3500...
after: display on (posedge fftclk)+102                       ( 602,1602,2602...)


"top_fft.fftram.SRAM000 1000: Reading rd_data_o mem[0] <= 3f80000000000000"
"SRAM000 t5  1000: Read(f) wr_data_i mem[0] <= ( 1.000000, 0.000000)"
srams read on (negedge clk) if (~ez & wz)                    (1000,2000,3000...

srams latch address ("SRAM000[3]") on (posedge clk)          (1500,2500,3500...

"top_fft.fftram.SRAM000 2000: Wrote   wr_data_i mem[0] <= 3f80000000000000"
"SRAM000 t5  2000: Wrote(f) wr_data_i mem[0] <= ( 1.000000, 0.000000)"
srams write on (negedge clk)                                 (2000,3000,4000...
USING PREV ix2bfly translation!!!

"FOOG   5000 Bypassed SRAM 0010, wrote ( 1.000000, 0.000000) to bypass_buffer\n",
sram writes bypass_buf on (negedge clk)
USING PREV(?) ix2bfly translation!!!
knows $sram, needs $bfly and $ix => needs $sram2ix (known) and $PREV_ix2bfly


"SRAM000 t5  2000: Wrote(f) wr_data_i mem[0] <= ( 1.000000, 0.000000)"
knows $sram, needs $bfly and $ix => needs $sram2ix (known) and $ix2bfly



------------------------------------------------------------------------------
SRAM's always latch write address on POSEDGE CLK2
port srams read/write on EVERY CLOCK EDGE
1port srams read/write on negedge only

2port srams read on posedge and negedge, write (and read) on posedge
1port srams read on negedge, write on negedge

read data  (SRAM000_rd_data) valid while match is true
write data (SRAM000_wr_data) only valid at negedge+100



op reads (
  "top_fft.BFLY0 t5  1002: in1(r,i)= ( 1.000000, 0.000000)" =>
  "DBG3- FINAL 001002 BFLY0_op1 reads  ( 1.000000, 0.000000) [ from  () ]"
)
happen on (every fftclk edge) + 2 IF ready is true  (1002,1502,...)








==============================================================================
(posedge start) && (~reset) =>
      bfly_op_ix_mem_ix <= 0;
      out2_offset <= 1;
      LAST <= 0;
      //@(negedge clk_i) STARTED <= 1;
      STARTED <= 1;



2port:
  bnum valid while ix valid
  ix (fftctl) changes on (posedge fftclk) + 100







