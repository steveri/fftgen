haha at long last, all tests pass

NEXT
- check everything in
- set up travis to run w/ verilator
- clean everything up, maybe start with README
- maybe try a clean install based on the new README
- haha just for fun maybe find all the FIXME's
- add dependences to README, maybe see slang for template https://github.com/MikePopoloski/slang
- set up a nightly cron job

==============================================================================

for SRAM/2PORT, try always @ (poedge clk_i or negedge clk_i) or whatever



Verilated model didn't converge

    Verilator sometimes has to evaluate combinatorial logic multiple
    times, usually around code where a UNOPTFLAT warning was issued,
    but disabled. For example:

    always @ (a)  b=~a;
    always @ (b)  a=b

    will toggle forever and thus the executable will give the didn't
    converge error to prevent an infinite loop.

    To debug this, run Verilator with --profile-cfuncs. Run make on
    the generated files with "OPT=-DVL_DEBUG". Then call
    Verilated::debug(1) in your main.cpp.

    This will cause each change in a variable to print a message. Near
    the bottom you'll see the code and variable that causes the
    problem. For the program above:

    CHANGE: filename.v:1: b
    CHANGE: filename.v:2: a


 verilator --profile-cfuncs -Wno-fatal -Wall --cc ${top} --exe ${cpp} --trace \
  -y ${vdir} -y ${fpu} |& tee verilator.log$i


make OPT=-DVL_DEBUG -j -C obj_dir/ -f Vtop_fft.mk Vtop_fft |& tee make.log$i | less

obj_dir/Vtop_fft  | tee tmp.log | less



        CHANGE: genesis_verif//fftram_unq1.v:104: v.fftram.SRAM000_wr_data
        CHANGE: genesis_verif//fftram_unq1.v:105: v.fftram.SRAM001_wr_data


------------------------------------------------------------------------------





STATUS

    cd regression; ../bin/golden_test.csh -sim vcs
    all 47 vcs tests PASS 

    cd regression; ../bin/golden_test.csh -sim verilator
    19 1port tests PASS
    19 2port tests FAIL
     9 dpump tests PASS
    47 tests total

NEXT
 - clean up
 - re-regress vcs and verilator
 - check in

DONE - CLEAN SO FAR
- Makefile
- gold...test.csh
- gold...test.pl
- Makefile (reg)
- fftctl
- addsub, sradd, srmul, srsub
- fft.cpp
- ...and the rest.


(../bin/golden_test.csh -sim verilator >& gold_ver.log1;\
../bin/golden_test.csh -sim vcs       >& gold_vcs.log1) &



------------------------------------------------------------------------------
huh.
looks like we may have fixed 1port problem by commenting out this line in fftctl:
     //; #if ($SRAM_TYPE eq "TRUE_1PORT") { $last_cycle++; } # Plus one cycle for the final write.

BUT still don't know why 16-1-1 got different op1 results at t=33500 (see below)



------------------------------------------------------------------------------
Looks like maybe P, ir are too small inverilator version (beelow).
Also: why does verilator do it TWICE?

verilator:
GENOPS2 (t=033500) ii,i: (0,1) => (0,16)
GENOPS2 (t=033500) > P = 0000
GENOPS2 (t=033500) > ir= 1111
GENOPS2 (t=033500) > op1= 000001101111
GENOPS2 (t=033500) > op2= 000000001111

vcs:
GENOPS2 (t=033500) ii,i: (0,1) => (0,16)
GENOPS2 (t=033500) > P = 00000000
GENOPS2 (t=033500) > ir= 00001011
GENOPS2 (t=033500) > op1= 00001011
GENOPS2 (t=033500) > op2= 00001011



verilator:
fftctl 33500: cycle_num = 32
fftctl 33500: fftctl_cycle_num_o = 31
fftctl 33500: out2_offset = 16
GENOPS2 (t=033500) ii,i: (0,1) => (0,16)
GENOPS2
GENOPS2 (t=033500) > P = 0000
GENOPS2 (t=033500) > ir= 0000
GENOPS2
GENOPS2 (t=033500) > op1= 000000000000
GENOPS2 (t=033500) > op2= 000000000000
GENOPS2
GENOPS2 (t=033500) ops=( 0, 0)
GENOPS2 -----------------------------------------------------
GENOPS2 (t=033500) ii,i: (0,1) => (0,16)
GENOPS2
GENOPS2 (t=033500) > P = 0000
GENOPS2 (t=033500) > ir= 1111
GENOPS2
GENOPS2 (t=033500) > op1= 000001101111
GENOPS2 (t=033500) > op2= 000000001111
GENOPS2
GENOPS2 (t=033500) ops=(111,15)
GENOPS2 -----------------------------------------------------

vcs:
fftctl 33500: cycle_num = 32
fftctl 33500: fftctl_cycle_num_o = 31
fftctl 33500: out2_offset = 16
GENOPS2 (t=033500) ii,i: (0,1) => (0,16)
GENOPS2
GENOPS2 (t=033500) > P = 00000000
GENOPS2 (t=033500) > ir= 00001011
GENOPS2
GENOPS2 (t=033500) > op1= 00001011
GENOPS2 (t=033500) > op2= 00001011
GENOPS2
GENOPS2 (t=033500) ops=(11,11)
GENOPS2 -----------------------------------------------------




problem: in SRAM000 verilator version, wz_i goes negative at beginning of cy 34. why?


------------------------------------------------------------------------------


16-1-1 too many writes:

egrep 'Wrote|ncy' fft.log | t40

TOP.v.fftram.SRAM001 33500: Wrote   wr_data_i mem[2] <= 3f8000003f2b0dc0
SRAM001 t5 33500: Wrote(f) wr_data_i mem[2] <= ( 1.000000, 0.668179)
TOP.v.fftram.SRAM003 33500: Wrote   wr_data_i mem[0] <= 3f800000bfbf90c6
SRAM003 t5 33500: Wrote(f) wr_data_i mem[0] <= ( 1.000000,-1.496606)
clock.vp: reset=0, ncy=  34, time= 34500 ns
TOP.v.fftram.SRAM000 34500: Wrote   wr_data_i mem[0] <= 4180000000000000
SRAM000 t5 34500: Wrote(f) wr_data_i mem[0] <= (16.000000, 0.000000)
clock.vp: reset=0, ncy=  35, time= 35500 ns
clock.vp: reset=0, ncy=  36, time= 36500 ns
clock.vp: reset=0, ncy=  37, time= 37500 ns



------------------------------------------------------------------------------



haha ENDED TOO EARLY!!! for verilator


tail 1611*simlog
==> 1611_vcs.simlog <==

clock.vp: ENDING AFTER 38 CLOCKS time=38000 ps,  ncy=38


$finish called from file "genesis_verif/clock_unq1.v", line 116.
$finish at simulation time                38000
           V C S   S i m u l a t i o n   R e p o r t 
Time: 38000 ps
CPU Time:      0.670 seconds;       Data structure size:   0.1Mb
Sat Jun 15 19:45:54 2019

==> 1611_verilator.simlog <==
TOP.v.BFLY0 t5 17500: t1a =  2.000000
TOP.v.BFLY0 t5 17500: t1b =  0.000000
TOP.v.BFLY0 t5
TOP.v.BFLY0 t5 17500: t2  =  0.000000
TOP.v.BFLY0 t5 17500: t2a =  0.000000
TOP.v.BFLY0 t5 17500: t2b =  0.000000
TOP.v.BFLY0 t5
TOP.v.BFLY0 t5 17500: out1(r,i)= (in1_real+t1, in1_imag+t2) = ( 4.000000, 0.000000)
TOP.v.BFLY0 t5 17500: out2(r,i)= (in1_real-t1, in1_imag-t2) = ( 0.000000, 0.000000)
TOP.v.BFLY0 t5 ------------------------


------------------------------------------------------------------------

some pass, some fail

e.g. 16 1 1:
TR FAIL: 12 mismatched results --- 16 1 1port (verilator)
less /tmp/golden_test_16_1_1port.log
Real results:  GM        FFT
                 8.000        2.000 *** ERROR '    8.00' ne '    2.00'
                 1.000        1.000
                 0.000        0.000
                 1.000        1.000
...



------------------------------------------------------------------------

so this happened:

cd fftgen/regressions
../bin/golden_test.csh -sim verilator 8 1 1port |& tee 811_verilator.log
1/1 tests PASSED


------------------------------------------------------------------------------

top=genesis_verif/top_fft.v
cpp=../tst/fft.cpp
vdir=genesis_verif/
fpu=../rtl/lib/

verilator -Wno-fatal -Wall --cc 
${VTOP} --exe ${cpp} --trace -y ${vdir} -y ${fpu}\



verilator -Wno-fatal -Wall --cc 
genesis_verif/top_fft.v --exe ../tst/fft.cpp 
--trace -y genesis_verif/ -y ../rtl/lib/



This works, in tmp.verilator directory:
mf cleanall
mf run_verilator |& tee run.log


what's next?


------------------------------------------------------------------------------

TODO
- "cleanall" should delete obj_dir, yes??


no errors
go check mail for awhile i guess

STATUS
cd fftgen/tmp.verilator

grep -v top_fft.v genesis_vlog.vf > verilator_list.vf
c; verilator -Wno-fatal -Wall --exe --trace --cc \
  /nobackup/steveri/github/fftgen/tmp.verilator/genesis_verif/top_fft.v \
  -f /nobackup/steveri/github/fftgen/tmp.verilator/verilator_list.vf \
  -y /nobackup/steveri/github/fftgen/rtl/lib \
  |& tee tmp.log

  -f /nobackup/steveri/github/fftgen/tmp.verilator/genesis_vlog.vf \


------------------------------------------------------------------------------
Debugging, current status:

c; verilator -Wno-fatal -Wall --exe --trace --cc   
-f /nobackup/steveri/github/fftgen/tmp.verilator/genesis_vlog.vf   
-y /nobackup/steveri/github/fftgen/rtl/lib

%Error: /nobackup/steveri/github/fftgen/rtl/lib/addsub.v:83: Unsupported or unknown PLI call: $bitstoshortreal
%Error: /nobackup/steveri/github/fftgen/rtl/lib/addsub.v:86: Unsupported or unknown PLI call: $bitstoshortreal




doing this now, thought it had already been done...
  diff genesis_verif/top_fft.v ../verilator/rtl/top_fft.v | less



OKAY should now be able to build verilator using
make -f ../Makefile SIM=verilator
...right???





WHEN WE COME BACK:
- untangle that crap below down there


Makefile before:
  all: run
  run: 
  gen: $(GENESIS_VLOG_LIST) $(GENESIS_SYNTH_LIST) $(GENESIS_VERIF_LIST)
  $(SIMV):$(GENESIS_VLOG_LIST)
	vcs  $(VERILOG_COMPILE_FLAGS) -f $(RUNDIR)/$(GENESIS_VLOG_LIST) $(COMP)
	@echo ""
	@echo Now Running simv
	@echo ==================================================
	$(SIMV) $(VERILOG_SIMULATION_FLAGS) $(RUN)
  .PHONY: run
  run: $(SIMV)
	vcs  $(VERILOG_COMPILE_FLAGS) -f $(RUNDIR)/$(GENESIS_VLOG_LIST) $(COMP)

.PHONY: run_verilator
run_verilator: obj_dir/Vtop_fft $(DESIGN_HOME)/bin/bsr.awk
	obj_dir/Vtop_fft |& ../bin/bsr.awk %9.6f > fft.log



obj_dir/Vtop_fft: obj_dir/Vtop_fft.mk
make -j -C obj_dir/ -f Vtop_fft.mk Vtop_fft |& tee make.log$i | less



# top=rtl/top_fft.v - use $(GENESIS_TOP)
# cpp=fft.cpp; 
VERILATOR_TESTBENCH := $(TOP).cpp
# vdir=rtl/ - use $(RUNDIR) (should be location of genesis_verif/)
# handwritten fpu components are in rtl/lib (for now)
obj_dir/Vtop_fft.mk:
	# verilator -Wno-fatal -Wall --cc ${top} --exe ${cpp} --trace -y ${vdir}
	verilator ${VERILATOR_TESTBENCH} -Wno-fatal -Wall --exe --trace \
	  --cc ${GENESIS_TOP} \
	  -f $(RUNDIR)/$(GENESIS_VLOG_LIST) \
	  -y  $(DESIGN_HOME)/rtl/lib



RUNDIR := $(shell cd ./; pwd -P)
GENESIS_VLOG_LIST := genesis_vlog.vf









	vcs  $(VERILOG_COMPILE_FLAGS) -f $(RUNDIR)/$(GENESIS_VLOG_LIST) $(COMP)
VERILOG_COMPILE_FLAGS := 	-sverilog 					\
                                ...
				-ld $(VCS_CC) 					\
				-top $(SIM_TOP)					\
				$(VERILOG_FILES) $(VERILOG_LIBS)
VERILOG_LIBS := \
  -y $(RUNDIR) +incdir+$(RUNDIR) \
  -y      $(SYNOPSYS)/dw/sim_ver \
  +incdir+$(SYNOPSYS)/dw/sim_ver \
  -y      $(DESIGN_HOME)/rtl/lib \
  +incdir+$(DESIGN_HOME)/rtl/lib



cd $fft/verilator
top=rtl/top_fft.v; cpp=fft.cpp; vdir=rtl/
echo $top $cpp $vdir

top=genesis_verif/top_fft.v
cpp=../tst/fft.cpp
vdir=genesis_verif/
fpu=../rtl/lib/

verilator -Wno-fatal -Wall --cc ${top} --exe ${cpp} --trace -y ${vdir} -y ${fpu}\
  |& tee verilator.log$i | tail




HOW-TO verilator - RUN
i=4
echo mv obj_dir obj_dir`expr $i - 1`
verilator -Wno-fatal -Wall --cc ${top} --exe ${cpp} --trace -y ${vdir} \
  |& tee verilator.log$i | less
make -j -C obj_dir/ -f Vtop_fft.mk Vtop_fft |& tee make.log$i | less

obj_dir/Vtop_fft |& ../bin/bsr.awk %9.6f\
  | egrep -v 'srmul|FPU' \
  | sed 's/^TOP.v/top_fft/' \
  | tee fft.log$i | less



NEXT verilator
- build golden -sim verilator



14 jun 2019 all regression tests pass (vcs):
  mkdir regression; cd regression
  ../bin/golden_test.csh >& gold.log &
  tail -f gold.log | egrep 'PASS|ERR'




HOLY CRAP it's gonna pass
So maybe everything works with vcs and bsr
So what's next?
- check everything in
- see where we are with the verilator


OLD maybe
  i=69
  cd build
  ../bin/golden_test.csh >& gold.log$i &
  tail -f $log | egrep "PASS|FAIL|ERR"

HOWTO do a quick test maybe (does this work?)
  mkdir build
  alias mf='make -f ../Makefile'
  cd build
  mf test8


------------------------------------------------------------------------------
GOLDEN TESTS csh vs. pl
  # To build and check a new simv.log from scratch:
  ../bin/golden_test.csh 8 1 1port |& tee gold.log$i | tail
  
  # To check an existing simv.log:
  ../bin/golden_test.pl 8 1 1port |& tee gold.log$i | tail
------------------------------------------------------------------------------


LATER
- should rtl/ subdir  be renamed gsource/ or something?

------------------------------------------------------------------------
HOWTO check vcs/rtl

i=1
diff -r ../verilator/rtl rtl | less
vcs -sverilog +cli +lint=all,noVCDE +libext+.v -notice -full64 \
  +v2k -debug_pp -timescale=1ps/1ps \
  +noportcoerce +vcs+lic+wait -licqueue -ld gcc -top top_fft \
  -y /hd/cad/synopsys/dc_shell/latest/packages/gtech/src_ver/ \
  +incdir+/hd/cad/synopsys/dc_shell/latest/packages/gtech/src_ver/ \
  -y ./rtl/ +incdir+./rtl/ -f fft.vf | tee vcs.log$i | tail

simv +vcs+dumparrays |& ../bin/bsr.awk %9.6f | tee simv.log$i | tail
diff simv.log$i simv.log0

sort simv.log5 > simv.sorted5
sort simv.log$i > simv.sorted$i
diff simv.sorted{2,$i} | h40

cp fft.vcd fft.vcd$i
diff fft.vcd0 fft.vcd$i | h40


cp simv.log$i simv.log
../bin/golden_test.pl 8 1 1port |& tee gold.log$i | tail
------------------------------------------------------------------------


LATER consider renaming sradd, srsub... fpadd_sr, fpsub_sr etc
- clean up snapshots ~/fftgen* maybe
- clean up fftgen maybe

TODO FIX SRAM'S!!!
- use standard async design
- move all weird clocking to SRAM driver :(


verilator -Wno-fatal -Wall --cc ${top} --exe ${cpp} --trace -y ${vdir} \
  |& tee verilator.log$i | less

------------------------------------------------------------------------
HOW-TO verilator - SETUP
cd $fft/verilator
top=rtl/top_fft.v; cpp=fft.cpp; vdir=rtl/
echo $top $cpp $vdir

HOW-TO verilator - RUN
i=4
echo mv obj_dir obj_dir`expr $i - 1`
verilator -Wno-fatal -Wall --cc ${top} --exe ${cpp} --trace -y ${vdir} \
  |& tee verilator.log$i | less
make -j -C obj_dir/ -f Vtop_fft.mk Vtop_fft |& tee make.log$i | less
obj_dir/Vtop_fft |& ../bin/bsr.awk %9.6f\
  | egrep -v 'srmul|FPU' \
  | sed 's/^TOP.v/top_fft/' \
  | tee fft.log$i | less

------------------------------------------------------------------------


clean to here
==============================================================================
DONE 1906
DONE 1906


REBOOT------------------------------------------------------------------


------------------------------------------------------------------------
VERILATOR VERSION

cd verilator
cp -rp ../811vcs/rtl .

copy fft.cpp from old verilator directory, check it for errors etc.
update top_fft, refer to old verilator
cd rtl
cp top_fft.v top_fft.v.vcs
cp ../../verilator.round1/rtl/top_fft.v top_fft.v.ver1
chmod -w top_fft.v.*

------------------------------------------------------------------------
VCS VERSION

TODO
- fix up 881vcs
-- alter 'make test8' to build fft.vcd maybe
-- alter 'Makefile' to build fft.vcd maybe

cd $fft
make test8
mv tmpXXX/ 811vcs/

THEN
- have to (re)build vcd file correctly now :(

vcs -sverilog +cli +lint=all,noVCDE +libext+.v -notice -full64 \
 +v2k -debug_pp -timescale=1ps/1ps \
 +noportcoerce +vcs+lic+wait -licqueue -ld gcc -top top_fft -y \
 /hd/cad/synopsys/dc_shell/latest/packages/gtech/src_ver/ \
 +incdir+/hd/cad/synopsys/dc_shell/latest/packages/gtech/src_ver/ -y \
 ./rtl/ +incdir+./rtl/ -f tmp.vf | tee vcs.log | tail

simv +vcs+dumparrays |& tee simv.log | tail


cd $fft
make test8

TODO
- document memory array / vcd stuff?


------------------------------------------------------------------------
HOWTO dump memory arrays to vcd file:

In clock_unq1.v:
   initial begin
     $dumpon;
     $dumpfile("fft.vcd");
   end

IN vcs command line: nothing. no memcbk, no dumpvars, no nothing
Example vcs command that works

vcs -sverilog +cli +lint=all,noVCDE +libext+.v -notice -full64 \
  +v2k -debug_pp -timescale=1ps/1ps \
  +noportcoerce +vcs+lic+wait -licqueue -ld gcc -top top_fft \
  -y /hd/cad/synopsys/dc_shell/latest/packages/gtech/src_ver/ \
  +incdir+/hd/cad/synopsys/dc_shell/latest/packages/gtech/src_ver/ \
  -y ./rtl/ +incdir+./rtl/ -f tmp.vf | tee vcs.log | tail

simv +vcs+dumparrays |& tee simv.log | tail

For things that did NOT work see $fft/archives/vcd-mem-thrashing.txt

------------------------------------------------------------------------
next: CLEAN UP!!!


/cad/synopsys/vcs/I-2014.03-2/doc/UserGuide/pdf/vcs.pdf


------------------------------------------------------------------------
------------------------------------------------------------------------
------------------------------------------------------------------------
------------------------------------------------------------------------



# npoints="top_fft.n_fft_points=8"
# nbutts="top_fft.units_per_cycle=1"
# sram="top_fft.SRAM_TYPE=TRUE_1PORT"
# alg="top_fft.swizzle_algorithm=round7"
# echo GENESIS_PARAMS="$npoints $nbutts $sram $alg"
# 
# # make -f ../bin/../Makefile \
# make \
# clean gen TOP=fft \
# GENESIS_PARAMS="$npoints $nbutts $sram $alg" \
# >& test_8_1_1port.log
# 
# ../bin/golden_test.pl 8 1 1port |& tee gold.log$i | less






==============================================================================




TODO
- NO INITIAL BEGINS right?
- start should stay high for a full cycle maybe why not
- reset should be generated in top_fft.v, yes?



awk -f ../bin/process_test5.awk ncsim.log >& ncsim.processed









NEXT
- log convergence, see TODO CONVERGENCE below
- then back to "CHECK ANSWERS" then "ADV COMPARE"



TODO CONVERGENCE - fft.log, ncsim.log convergence (converge verilator, ncsim logs)
- debugging
- works like this:
- compare fft.log$i to ncsim.log
- squelch diffs
- repeat




LATER
- work on regression tests for verilator
- clean up / rename the other todo's
- consider replacing todo's with github issues maybe
- WOW really need to clean up bin/ directory
- haha fft.cpp opens "counter.vcd"

DONE 1906
- got rid of 13's checked the answer (round2 i=4)
- time to snapshot to next i i guess
- golden test (ADV. COMPARE) and "CHECK ANSWERS" failed miserably
  (see below), so back to log convergence


------------------------------------------------------------------------
HOW-TO - SETUP
cd $fft/verilator
top=rtl/top_fft.v; cpp=fft.cpp; vdir=rtl/

HOW-TO - RUN
i=4
echo mv obj_dir obj_dir`expr $i - 1`
verilator -Wno-fatal -Wall --cc ${top} --exe ${cpp} --trace -y ${vdir} \
  |& tee verilator.log$i | less
make -j -C obj_dir/ -f Vtop_fft.mk Vtop_fft |& tee make.log$i | less
obj_dir/Vtop_fft |& ../bin/bsr.awk %9.6f\
  | egrep -v 'srmul|FPU' \
  | sed 's/^TOP.v/top_fft/' \
  | tee fft.log$i | less

HOW-TO - CHECK ANSWERS
awk -f ../bin/process_test5.awk ncsim.log >& ncsim.processed; tail ncsim.processed
awk -f ../bin/process_test5.awk fft.log$i >& fft$i.processed; tail fft$i.processed

HOW-TO - ADVANCED COMPARE
cp fft.log$i simv.log
../bin/golden_test.pl 8 1 1port |& tee gold.log$i | less


DONE
- see if golden-test works NOPE
- if not, continue with TODO CONVERGENCE below


SRAM restore did not work


Compare fft.log2, ncsim.log...looks pretty good, no?

f=`diff -r rtl round1/rtl4 -q | grep differ | awk '{print $2}'`
echo $f
mkdir rtl$i
cp $f rtl$i/


PLAN:
- capture what you got
- increment i
- try restoring SRAM_unq[1234], output should not change
- document EVERYTHING
- sleep

WOW this looks promising
can we capture what we got so far?
- main thing was we restored fftctl
- maybe try restoring SRAM_unq[1234]



thingsa lookin GOODY! NEXT:
- save all changes
- continue w/same i




TODO ZERO - modify rtl to emit bsr's instead of 13.13's
- save existing state to round1
- ready round 2: see how-to, above
- once 13.13's have been purged:
  cd $fft/verilator
  ../bin/bsr.awk < fft.log$i > fft.log$i.bsr
  diff fft.log$i fft.log$i.bsr





TODO ONE
- compare new to old fft logs


-- looks like verilator log is $fft/verilator/fft.log6
-- 

-- verilator simv > t64_verilator.log.raw
-- bin/bsr.awk < t64_verilator.log.raw > t64_verilator.log.bsr
-- gunzip -c $fft/test/examples/test_64_1_1port.log.gz > t64_ncsim.log
-- diff t64_ncsim.log t64_verilator.log.bsr
-- probably won't match, go on to TODO TWO anyway

TODO TWO
- merge verilator, ncsim code, use regression tests to stay on track



DONE
- bin/bsr.awk works maybe


------------------------------------------------------------------------------
time to make verilator work!!!

1. build genesis_verif using simplest 8-1-1 test
2. try this:

  cd verilator
  alias mf='make -f ../Makefile'
  npoints="top_fft.n_fft_points=8"
  nbutts="top_fft.units_per_cycle=1"
  sram="top_fft.SRAM_TYPE=TRUE_1PORT"
  alg="top_fft.swizzle_algorithm=round7"

  make -f ../bin/../Makefile \
  clean gen TOP=fft \
  GENESIS_PARAMS="$npoints $nbutts $sram $alg" \
  >& test_8_1_1port.log




------------------------------------------------------------------------------
STATUS 1905
- new fpu seems stable, works on 47 fft regressions, see rtl/lib/0notes-fpu.txt
- maybe put fpu in rtl/fpu or rtl/lib/fpu instead of rtl/lib or something maybe



TODO
- also see rtl/lib/0notes-fpu.txt
- ELIMINATE LINT ERRORS!!! 
- test and see if still works with designware maybe
- PORT TO VERILATOR!
- also do a system test /complete runthrough i.e. clone from scratch and see if it works


HOW TO RUN REGRESSIONS
- cd regressions; make regress

HOW TO RUN A SINGLE FFT TEST (should say "1/1 tests PASSED")
- cd test; make
- OR cd test; make test_64_1_1port

HOW TO TEST THE FPU
- cd test; make fptest_64_1_1port
- OR cd test; make test_64_1_1port; ../bin/fptest3.awk test_64_1_1port.log
# Sample output:
#   % fptest3.awk test_128_1_1port.log$i |& less
#   ...
#   fptest o2i.FPU.SUB      (0.414214 - 1.082392)     =  -0.668179 true
#   fptest o2i.FPU..SUB    (-0.414214 - -1.082392)    =   0.668179 true
#   fptest o1i.FPU..ADD    (-0.414214 + -1.082392)    =  -1.496606 true
#   fptest o2r.FPU..SUB     (1.000000 - 0.000000)     =   1.000000 true
#   fptest o1r.FPU..ADD     (1.000000 + 0.000000)     =   1.000000 true
#   fptest t2.FPU..ADD     (-0.923880 + -0.158513)    =  -1.082392 true
#   fptest t1.FPU.ADD       (0.382683 + 0.382683)     =   0.765367 true
#   top_fft.BFLY0 t5 ------------------------
#   ...




DONE
- debug 128 1 dpump or whatever
- 


STATUS 5/25
- verified the following for srsub 4-1, 4-3, 1-4, 3-4
- appears to have successfully PASSED golden_test.csh 64 1 1port
- appears to have FAILED 128 1 dpump

CONTEXT
  cd github/fftgen/tmp.regress
  egrep 'PASS|ERR' log2 | less


NEXT
- debug 128 1 dpump or whatever
- try regression tests i guess FAILES
- see rtl/lib/0notes-fpu.txt
- clean up below



STATUS
- fft currently broken i think b/c fpu
-- cd build; mf cleanall; ../bin/golden_test.csh 8 1 1port |& tee tmp.log0
-- also see build/round4/

- working on fpu, see rtl/lib/0notes-fpu.txt






NEXT
- check it in!
- then: continue debugging


DONE
- move all to github READY!!! -> IN PROGRESS -> DONE
-- offload docs => /home/steveri/projects/fft/doc/ DONE
-- move everything I guess, but first get rid of big trash maybe


DEBUGGING
  alias mf='make -f ../Makefile'
  cd build
  mf cleanall
  i=8
  ../bin/golden_test.csh 8 1 1port |& tee tmp.log$i
  cp /tmp/test_8_1_1port.log test_8_1_1port.log$i
  less test_8_1_1port.log$i
  diff tmp.log[78]

  DEBUG; check in
  etc.




Clean up golden_test output:

  cd build; ../bin/golden_test.csh 8 1 1port |& tee tmp.log

first problem: weird path name
  make -f ../bin/../Makefile clean ...





NEXT?
- clean up README.txt
- README.txt => README.md ?
- try out README etc.
- clean up below

LATER
- gui???




  make -f ../bin/../Makefile clean gen TOP=fft
  GENESIS_PARAMS="top_fft.n_fft_points=32 top_fft.units_per_cycle=2
  top_fft.SRAM_TYPE=TRUE_1PORT top_fft.swizzle_algorithm=round7" >&
  /tmp/test_32_2_1port.log



Make notes in 0notes.txt
Publish to README.md
Also see ~/0notes/fftgen-2019.txt

FFTGEN_DIR=`pwd`
mkdir build/
cd build/
make -f $FFTGEN_DIR/Makefile gen


c; bin/golden_test.csh 32 2 1port |& tee golden_test_32_2_1port.log



unlinked: github -> /nobackup/steveri/github/fftgen/


TODO
- need some way to run in subdirectory
-- i.e. separate "build" subdirectory? should start out empty, yes?

thing to try:
c; bin/golden_test.csh |& tee golden_test_all.log





TODO
- README.txt => README.md
- README_files.txt => ???

8 may 2019

c; bin/golden_test.csh 32 2 1port |& tee golden_test.log2


Seems to be working(!!!)
- deleted this from makefile: "export VCS_ARCH_OVERRIDE=linux"



TODO
- seems like there should be a bin/setup_vcs.sh ??


1. Need a working Genesis2 in your path. This will check for that:
   which Genesis2
   source bin/setup_genesis.sh  
   export PATH=.:/home/steveri/bin:/usr/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/sbin:/bin:/cad/common/Linux/x86_64/bin:/cad/synopsys/vcs/O-2018.09-SP1/bin:/cad/synopsys/vcs/O-2018.09-SP1/gui/dve/bin:/tmp/Genesis2/Genesis2Tools/bin:/tmp/Genesis2/Genesis2Tools/gui/bin


2. Need Synopsys' vcs tool in your path. On kiwi:
   (TODO should be a bin/setup_vcs.sh, yes?)
   which vcs
   source /cad/modules/tcl/init/sh
   module load base
   module load vcs
   export PATH=.:/home/steveri/bin:/usr/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/sbin:/bin:/cad/common/Linux/x86_64/bin:/cad/synopsys/vcs/O-2018.09-SP1/bin:/cad/synopsys/vcs/O-2018.09-SP1/gui/dve/bin

   vcs -full64 -help | head



3. Now give it a shot, now that you're set up and all:

   bin/golden_test.csh 32 2 1port





7 may 2019
This is the fftgen directory ~/chipgen/fftgen

To run exhaustive regression test on kiwi (? not yet verified)

  kiwi% bin/switch.csh     # Result should be "round7"
  kiwi% source bin/setup_stanford.bashrc

  kiwi% ~/fftgen/bin/golden_test.csh           # Default, see above
  kiwi% ~/fftgen/bin/golden_test.csh 8 1 1port # For single test
  kiwi% ~/fftgen/bin/golden_test.csh -abbrev   # For D={8,16,32} only
  kiwi% ~/fftgen/bin/gt8k.csh                  # For D=(8,8192,4096,2048) only






------------------------------------------------------------------------
16 Jul 2014
This is the fftgen directory.

No longer using symbolic link to fft_scheduler_{old,new}; use
environment variable SCHED_ALG i.e. to access the old regime e.g.

  setenv SCHED_ALG mod_bn_combo
  bin/test_scheduler.pl > tstest2.mod_bn_combo
  diff tstest[02].mod_bn_combo

To test the scheduler in standalone mode, can do:

  unsetenv SCHED_ALG (defaults to new 'round7' algorithm)
  bin/test_scheduler.pl > tstest2.round7
  diff tstest[02].round7

To run exhaustive regression test:

  kiwi% switch.csh -n     # Result should be "new"
  kiwi% source ~/gui/configs/setup_stanford.cshrc

  kiwi% ~/fftgen/bin/golden_test.csh           # Default, see above
  kiwi% ~/fftgen/bin/golden_test.csh 8 1 1port # For single test
  kiwi% ~/fftgen/bin/golden_test.csh -abbrev   # For D={8,16,32} only
  kiwi% ~/fftgen/bin/gt8k.csh                  # For D=(8,8192,4096,2048) only

Also, new golden test incorporates choice of algorithm.  New
formal-proof algorithm 'round7' is now the default; to use old
previously-correct-ish version specify 'mod_bn_combo' use command-line
switch "-alg mod_bn_combo" algorithm, e.g.:

For old algorithm, do e.g.:

  kiwi% switch.csh -n     # Result should be "old"
  kiwi% ~/fftgen/bin/golden_test.csh -alg mod_bn_combo
  kiwi% ~/fftgen/bin/golden_test.csh -alg mod_bn_combo 8 1 1port
  kiwi% ~/fftgen/bin/golden_test.csh 8 1 1port mod_bn_combo
  kiwi% ~/fftgen/bin/golden_test.csh -alg mod_bn_combo -abbrev  
  kiwi% ~/fftgen/bin/gt8k.csh -alg mod_bn_combo

To analyze simv.log, try:
  set b=~/fftgen/bin/simv_analysis
  c ; $b/analyze_reads_and_writes.pl -d simv.log |\
  $b/summarize_reads_and_writes.pl | egrep -v '^IGNORE|BB|wr' |\
  uniq | sed 's/.*BREAK//' | less

------------------------------------------------------------------------
13 Jul 2014

As of 7/15 (p4 change 12008) both versions (old/mod_bn_combo,
new/round7) pass all std "golden_test" tests, and the gui works for at
least two configs "8 1 1" (13 cy) and "1024 4 1" (1281 cy).

------------------------------------------------------------------------------
3 Jul 2014

To see if the fft generator works, maybe try bin/golden_test.csh
(probably only works from kiwi).  
Default is (1,2)ports x (1,2,4)butterflies x (8,16,32...1024)datapoints

  kiwi% source ~/gui/configs/setup_stanford.cshrc

  kiwi% ~/fftgen/bin/golden_test.csh           # Default, see above
  kiwi% ~/fftgen/bin/golden_test.csh 8 1 1port # For single test
  kiwi% ~/fftgen/bin/golden_test.csh -abbrev   # For D={8,16,32} only
  kiwi% ~/fftgen/bin/gt8k.csh                  # For D=(8,8192,4096,2048) only


Prev simv.log appears to be for nunits=4 and npoints=2048.  Let's try duplicating that:

  % mkdir old; mv simv* old; mv old old_simv

  % source ~/gui/configs/setup_stanford.cshrc
  % bin/golden_test.csh 2048 4 1port
  % diff simv.log old_simv/simv.log

Is it possible I haven't done development work since May 2013?
  % ls -ltd ~/fftgen/simv*
  -rw-r--r-- 1 steveri users  5599428 Jul 15  2013 simv.log
  drwxr-xr-x 2 steveri users     4096 May 25  2013 simv.daidir/
  -rwxr-xr-x 1 steveri users 14450733 May 25  2013 simv*
  drwxr-xr-x 2 steveri users     4096 May 25  2013 simv.vdb/
  -rw-r--r-- 1 steveri users   231103 Feb  6  2013 simv.0

------------------------------------------------------------------------
OLD 1906
# HOWTO convert vpd to vcd - use 'vpd2vcd'
# DON'T NEED anymore, generate vcd directly, see above.
# 
# Synopsys waveform viewer:
#   dve -vpd vcdplus.vpd
# 
# BUT we don't generate vpd files no more
# 

------------------------------------------------------------------------------
NO! omg they're all backwards :(
# NO cp ../verilator/rtl/addsub.v rtl/addsub.v
# NO cp rtl/butterfly_unq1.v ../verilator/rtl/butterfly_unq1.v
# NO cp rtl/fftram_unq1.v ../verilator/rtl/fftram_unq1.v
# NO cp rtl/sradd.v ../verilator/rtl/sradd.v
# NO cp rtl/SRAM_unq1.v ../verilator/rtl/SRAM_unq1.v
# NO cp rtl/SRAM_unq2.v ../verilator/rtl/SRAM_unq2.v
# NO cp rtl/SRAM_unq3.v ../verilator/rtl/SRAM_unq3.v
# NO cp rtl/SRAM_unq4.v ../verilator/rtl/SRAM_unq4.v
# NO cp rtl/srmul.v ../verilator/rtl/srmul.v
# NO cp rtl/srsub.v ../verilator/rtl/srsub.v


DONE
# cp verilator/rtl/butterfly_unq1.v vcs/rtl/butterfly_unq1.v
# cp verilator/rtl/fftram_unq1.v vcs/rtl/fftram_unq1.v
# cp verilator/rtl/sradd.v vcs/rtl/sradd.v
# cp verilator/rtl/SRAM_unq1.v vcs/rtl/SRAM_unq1.v
# cp verilator/rtl/SRAM_unq2.v vcs/rtl/SRAM_unq2.v
# cp verilator/rtl/SRAM_unq3.v vcs/rtl/SRAM_unq3.v
# cp verilator/rtl/SRAM_unq4.v vcs/rtl/SRAM_unq4.v
# cp verilator/rtl/srmul.v vcs/rtl/srmul.v
# cp verilator/rtl/srsub.v vcs/rtl/srsub.v

DONE
# ------------------------------------------------------------------------------
# using perl to convert floating-point to bits:
# 
#     perl> printf("%08X\n", unpack("V", pack("f", 1.0)))
#     3F800000
# 
#     perl> printf("%08X\n", unpack("Q", pack("d", 1.0)))
#     3FF0000000000000
# ------------------------------------------------------------------------------

DONE 1906
# - run some golden tests, see what's gone wrong... DONE/FIXED
# STATUS okay generating clean rtl maybe
# try golden tests maybe, see what happens
# 
# STATUS: ALMOST DONE!!! with this part
# NEXT: twiddle i think
# 
# 
# c; diff -r -I 'Parameter' ../vcs/rtl genesis_verif | h40
# 
# - maybe add -I to 'help'diff'
# 
# NEXT: continue with "cleanall; gen; diffr"
# 
# NOW: think I got clock.vp fixed
# NEXT: sanity check time maybe? nope all or nothing now! grrr!!!
# 
# NEXT: clock.vp
# 
# diff -r ../vcs/rtl/clock_unq1.v genesis_verif/clock_unq1.v | less
# cleanall; gen; diff -r ../vcs/rtl/clock_unq1.v genesis_verif/clock_unq1.v | less
# continue

DONE 1906
# HOWTO converge genesis -> handcrafted vcs files
# cd $fftgen/build
# alias cleanall='make -f ../Makefile cleanall'
# alias gen='make -f ../Makefile gen'
# alias diffr='diff -r ../vcs/rtl genesis_verif | grep -v Parameter | grep -v savedir | less -S'
# cleanall; gen; diffr


DONE 1906
# THE ROAD SO FAR
# - minimal diffs b/w hand-tweaked vcs, verilog rtl, see:
# 
# cd vcs; diff -r ../verilator/rtl/top_fft.v rtl/top_fft.v
# 
# - check in DONE
# - snapshot to ~home DONE
# - work on clean vp2v transition:
#     cd $fftgen/build; make gen; diff -r genesis_verif ../vcs/rtl;

DONE 1906
- so far so good i guess
- fix remaining diffs including bsr maybe
-- must do top_fft by hand i think
-- also twiddle
- fix .vp files to match .v files
- and then and then...?

DONE 1906
- made a snapshot ~/fftgen.snapshot.190612.vcs.passed.regressions
- make a snapshot and start over with vcs/i=0
- regressions i guess



==============================================================================
NOTES from 9 jun 2019 ish

------------------------------------------------------------------------------
ncsim version works! right?
SO: start over
------------------------------------------------------------------------------

SRAM000_wz should be active when either banknum == 000 etc.


first cycle: in1,in2 = 1, 0 ; out1, out2 = 1, 1
second cycle: out1, out2 should write back to sram000, sram001

BUT NO

currently need TWO posedge clocks to setup
1. first clock edge sets ix
2. second clockedge uses ix to fetch ops

solutions?
- make SRAM continuous (again) instead of clocked



TWO THINGS
- 1. did not propagate sram_unq1 changes to 2,3,4
- 2. what is sram behavior when read/write on same cycle?



- out1,out2 stable @ posedge clk 1000/1500
- SRAM000,001 wz LOW/active @ posedge clk 1000/1500
- why no write to sram0,1?


==============================================================================
NOTES from 8 jun 2019 ish
# 
# i think it will work! see below
# - take gtkwave before/after screenshots
# - increment i before and after? maybe not i dunno
# 
# 
# "match" signals must be ready to go even while in reset...right?
# which means "bnum" signals must be preloaded...?
# "bnum" generated by swizzler unclocked bnum=f(addr)
# "addr" in top_fft is "op[12]_ix" generated by fftctl
# which works like this:
#    always @(posedge fftclk_o) begin
#       if (STARTED & ~rst_n_i) begin
#          {BFLY0_op1_ix_o,BFLY0_op2_ix_o} <= GenOps2(cycle_num, 0, stageno);
# 
# 
# 
# how terrible would this be:
# 
#    always @(posedge fftclk_o) begin
#       //if (STARTED & ~rst_n_i) begin
#          {BFLY0_op1_ix_o,BFLY0_op2_ix_o} <= GenOps2(cycle_num, 0, stageno);
# 
# 
# ...for this to work, maybe cycle_num and stageno have to be stable
# BEFORE reset...is this kosher???
# 
# 1500:
# - in2 should be zero RIGHT?
# - but in2 is 1.0 WHY?
# 
# 1500:
# - should be reading SRAM001 loc mem[0]
# - but not reading SRAM001 loc mem[0]
# - why?
# 
# 
# OKAY things are stable ISH maybe
# snapshot, increment i, continue debug...
# 
# In fftlog:
# fftram 1000: fft_started = 1
# fftram 1000: SRAM000_ez = 0
# 
# BUT I think I want ez OFF, ergo fft_started ZERO, for one more half cycle...
# 
# In fftram:
#    assign SRAM000_ez = ~fft_started | ~(
#         (BFLY0_op1_bnum_i == 0 ) | (BFLY0_op2_bnum_i == 0 ) | ~SRAM000_wz );
# 
# In top_fft:
#    fftram_unq1  fftram  // .remote(local)
#      ,.fft_started(busy | start)
# 
# original code in top_fft:
# //   always @(negedge rst_n) begin
# //      start <= 1'b1;
# //      @(posedge fftclk) begin start <= 1'b0; end
# new code:
#     // fftclk  ___.---.___.---.___.---.___.---
#     // rstn    -------._______________________
#     // ck_rn   -----------.___________________ ?
#     // rst2    ---------------._______________
#     // start   ___________.---._______________ ?
#     always @(posedge fftclk) ck_rn <= rst_n;
#     always @(negedge fftclk) rst2  <= ck_rn;
#     assign start = ~ck_rn & rst2;
# 
# 
# original code in clock.vp (reset on posedge!!!?
#       repeat(RST_PERIOD) @(posedge clk) reset = ~reset;  // Wait for RST_PERIOD posedges
# 
#    // I THINK I want fft_started OFF for one more half cycle...?
# 
# 
# two problems:
# 1) reading too soon: fft reads @1000
# SRAM000 t5  1000: Read(f) wr_data_i mem[0] <= ( 1.000000, 0.000000)
# 2) Reading wrong values maybe
# SRAM000 t5  1000: Read(f) wr_data_i mem[0] <= ( 1.000000, 0.000000)
# SRAM000 t5  1000: Read(f) wr_data_i mem[0] <= ( 1.000000, 0.000000)
# 
# fft:
# SRAM000 t5  1000: Read(f) wr_data_i mem[0] <= ( 1.000000, 0.000000)
# SRAM000 t5  1000: Read(f) wr_data_i mem[0] <= ( 1.000000, 0.000000)
# SRAM001 t5  1500: Read(f) wr_data_i mem[0] <= ( 0.000000, 0.000000)
# SRAM001 t5  1500: Read(f) wr_data_i mem[0] <= ( 0.000000, 0.000000)
# 
# 
# 
# ncsim:
# SRAM000 t5  1500: Read(f) wr_data_i mem[0] <= ( 1.000000, 0.000000)
# SRAM001 t5  1500: Read(f) wr_data_i mem[0] <= ( 0.000000, 0.000000)
# SRAM002 t5  2500: Read(f) wr_data_i mem[0] <= ( 1.000000, 0.000000)
# SRAM003 t5  2500: Read(f) wr_data_i mem[0] <= ( 0.000000, 0.000000)
# 
# 
# 
# Problem is here, in fft.log: wz_i SHOULD NOT BE ZERO
# # TOP.v.fftram.SRAM000 1500: ez_i=0 and wz_i=0
# # TOP.v.fftram.SRAM000 1500: Wrote   wr_data_i mem[0] <= 4000000000000000
# # SRAM000 t5  1500: Wrote(f) wr_data_i mem[0] <= ( 2.000000, 0.000000)
# # 
# # 
# # fftram 1500: fft_started = 1
# # fftram 1500: BFLY0_op1_bnum_i = 0
# # 
# # fftram 1500: SRAM000_ez = 0
# # fftram 1500: SRAM001_ez = 0
# # fftram 1500: SRAM002_ez = 1
# # fftram 1500: SRAM003_ez = 1
# # 
# # fftram 1500: SRAM000_wz = 0
# # fftram 1500: SRAM001_wz = 1
# # fftram 1500: SRAM002_wz = 1
# # fftram 1500: SRAM003_wz = 1
# 
# In fftram:
#       if ( fft_started & ( //TRUE
#          (BFLY0_op1_bnum_i == 0 ) //TRUE but FALSE (x) for ncsim!!
#          | (BFLY0_op2_bnum_i == 0 ) //DC
#      )) begin
#          SRAM000_wz <= suppress_wz_i[0];
# 
# ncsim:
# fftctl 1500: in( x, x), out( x,  x)
# fftctl 1500: cycle_num = 0
# top_fft 1602: BFLY0_op1 ix 00 comes from bank  0 row   0
# top_fft 1602: BFLY0_op2 ix 01 comes from bank  1 row   0
# 
# fftram 1500: fft_started = 1
# fftram 1500: BFLY0_op1_bnum_i = x
# 
# fftram 1500: SRAM000_wz = 1
# fftram 1500: SRAM001_wz = 1
# fftram 1500: SRAM002_wz = 1
# fftram 1500: SRAM003_wz = 1
# 
# bnum is generated by swizzler, where bnum = f(ix)
#    swizzle_unq1  BFLY0_op1_swizzle(
# .addr_i(BFLY0_op1_ix), 
# .rnum_o(BFLY0_op1_rnum), 
# .bnum_o(BFLY0_op1_bnum));
# 
# 
# 
# 
# In fftctl:
# OOOOOPS! 100 ps after? but i cannot find where that happens...?
#      ,input logic [3:0] suppress_wz_i  // one bit per bank, set 100 ps after posedge
# 
# 
#    logic [0:3] precomputed_suppress_wz [0:11];      // {0,1}
#    always @(posedge start_i) if (~rst_n_i) begin
#       suppress_wz_o <= 4'b0;
#    end
#          suppress_wz_o <= precomputed_suppress_wz[cycle_num];
# 
#        precomputed_suppress_wz[ 0] = 4'h0;
#        precomputed_suppress_wz[ 1] = 4'h0;
#        precomputed_suppress_wz[ 2] = 4'h0;
#        precomputed_suppress_wz[ 3] = 4'h4;

DONE oops did not expunge all %9.6f's
# 
# Do:
#   greps 9.6f ../rtl/* ../tst/*
# and/or
#   greps 9.6f rtl/* tst/*
# until they are all fixed!!!
# ../rtl/fftram.vp:         $display("fftram %6d Bypassed SRAM `$i`, wrote (%9.6f,%9.6f) to bypass_buffer[%1d]",
# ../rtl/SRAM.vp:      $display("`$myname` t5 %5d: Read(f) wr_data_i mem[%1d] <= (%9.6f,%9.6f)", $time, addr_i, `ri("rd_data_o")`);
# ../rtl/SRAM.vp:         $display("`$myname` t5 %5d: Wrote(f) wr_data_i mem[%1d] <= (%9.6f,%9.6f)", $time, addr_i, `ri("wr_data_i")`);
# ../rtl/SRAM.vp:         $display("`$myname` t5 %5d: Read(f) wr_data_i mem[%1d] <= (%9.6f,%9.6f)", $time, addr_i, `ri("rd_data_o")`);
# ../rtl/SRAM.vp:         $display("`$myname` t5 %5d: Wrote(f) wr_data_i mem[%1d] <= (%9.6f,%9.6f)", $time, addr_i, `ri("wr_data_i")`);
# 
# ../tst/top_fftram.vp:         $display("top_fftram %5d: out1_imag = %9.6f", $time, $bitstoshortreal(BFLY0_out1_data[`$imag`]));
# ../tst/top_fftram.vp:         $display("top_fftram %5d: out2_imag = %9.6f", $time, $bitstoshortreal(BFLY0_out2_data[`$imag`]));
# 
# 
# top_fft.fftram.SRAM000 1500: ez_i=0 and wz_i=1
# top_fft.fftram.SRAM000 1500: Reading rd_data_o mem[0] <= 3f80000000000000
# SRAM000 t5  1500: Read(f) wr_data_i mem[0] <= (1065353216.000000, 0.000000)

DONE 1906
# - 1port tests all work, hooray!
# - no 2port tests work, boo!
# - how to fix?
# -- build an unsuccessful 812 and save it
# -- build a successful 812 using one of the snapshots
# -- diff and fix
# 
# 
# 1. build an unsuccessful 812 using existing infrastructure
# 
#   mkdir build; cd build
#   ../bin/golden_test.csh 8 1 2port |& tee gold.log$i | tail  
# 
# Error-[IND] Identifier not declared
# genesis_verif/fftram_unq1.v, 170
#   Identifier 'cycle_num' has not been declared yet. If this error is not 
#   expected, please check if you have set `default_nettype to none.

DONE 1906
# okay. all the 1port tests passed
# check everything in i guess
# then maybe take a pause...
# then fix 2port/dpump :(
# 
# i mean, you *know* its the sram's...
# multiple ways to fix maybe...
# for now maybe just do ifdef 1port

DONE 1906
- running regressions
- regressions should pass (ha!)
- check everything in
- continue below
- TODO: grep for %f in rtl,tst files

DONE 1906
- good through SRAM_unq1 maybe
- NEXT continue with SRAM_unq2

DONE 1906 - SEEMS TO WORK according to waveforms
- cd vcs;       gtkwave fft.vcd fft.gtkw
- cd verilator; gtkwave counter.vcd counter.gtkw

DONE 1906
- see if new code works with vcs
- establish a baseline
-- do sequence below
-- check that diff give same simv.log GOOD
-- check that vcd file is still the same GOOD
- propagate changes from verilator/rtl
- repeat verification

DONE 1906
- snapshot everything to home dir fftgen.snapshot.190611

DONE/FIXED 1906
# new problem: 5/6 transition
# wz stays high, should go low...
# 
# plan is to disable wz when addr==x
# see printout, plus new signals wz[0123] in fftram
# TODO should also disable ez I suppose
# NOTE vcs version is WRONG but addr==x effectively disables writes anyway :(

DONE 1906
SRAM is a TERRIBLE SRAM!!!
- e.g. write is clocked on ez/wz edges!!?
- but read is not clocked at all :(
* should be able to make it work with standard SRAM!!!

DONE 1906
# Okay it compiles (verilator) w/o error.
# Next: make, obj/fft etc.
# 
# Okay think maybe I got fft_top done
# NEXT: Try a compile?

REBOOT DONE 1906
- build 811vcs.vcd DONE
- save old verilator directory
- build new verilator directory
- build 811v.vcd
- CONVERGE

